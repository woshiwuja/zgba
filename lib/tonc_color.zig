pub const __builtin_bswap16 = @import("std").zig.c_builtins.__builtin_bswap16;
pub const __builtin_bswap32 = @import("std").zig.c_builtins.__builtin_bswap32;
pub const __builtin_bswap64 = @import("std").zig.c_builtins.__builtin_bswap64;
pub const __builtin_signbit = @import("std").zig.c_builtins.__builtin_signbit;
pub const __builtin_signbitf = @import("std").zig.c_builtins.__builtin_signbitf;
pub const __builtin_popcount = @import("std").zig.c_builtins.__builtin_popcount;
pub const __builtin_ctz = @import("std").zig.c_builtins.__builtin_ctz;
pub const __builtin_clz = @import("std").zig.c_builtins.__builtin_clz;
pub const __builtin_sqrt = @import("std").zig.c_builtins.__builtin_sqrt;
pub const __builtin_sqrtf = @import("std").zig.c_builtins.__builtin_sqrtf;
pub const __builtin_sin = @import("std").zig.c_builtins.__builtin_sin;
pub const __builtin_sinf = @import("std").zig.c_builtins.__builtin_sinf;
pub const __builtin_cos = @import("std").zig.c_builtins.__builtin_cos;
pub const __builtin_cosf = @import("std").zig.c_builtins.__builtin_cosf;
pub const __builtin_exp = @import("std").zig.c_builtins.__builtin_exp;
pub const __builtin_expf = @import("std").zig.c_builtins.__builtin_expf;
pub const __builtin_exp2 = @import("std").zig.c_builtins.__builtin_exp2;
pub const __builtin_exp2f = @import("std").zig.c_builtins.__builtin_exp2f;
pub const __builtin_log = @import("std").zig.c_builtins.__builtin_log;
pub const __builtin_logf = @import("std").zig.c_builtins.__builtin_logf;
pub const __builtin_log2 = @import("std").zig.c_builtins.__builtin_log2;
pub const __builtin_log2f = @import("std").zig.c_builtins.__builtin_log2f;
pub const __builtin_log10 = @import("std").zig.c_builtins.__builtin_log10;
pub const __builtin_log10f = @import("std").zig.c_builtins.__builtin_log10f;
pub const __builtin_abs = @import("std").zig.c_builtins.__builtin_abs;
pub const __builtin_labs = @import("std").zig.c_builtins.__builtin_labs;
pub const __builtin_llabs = @import("std").zig.c_builtins.__builtin_llabs;
pub const __builtin_fabs = @import("std").zig.c_builtins.__builtin_fabs;
pub const __builtin_fabsf = @import("std").zig.c_builtins.__builtin_fabsf;
pub const __builtin_floor = @import("std").zig.c_builtins.__builtin_floor;
pub const __builtin_floorf = @import("std").zig.c_builtins.__builtin_floorf;
pub const __builtin_ceil = @import("std").zig.c_builtins.__builtin_ceil;
pub const __builtin_ceilf = @import("std").zig.c_builtins.__builtin_ceilf;
pub const __builtin_trunc = @import("std").zig.c_builtins.__builtin_trunc;
pub const __builtin_truncf = @import("std").zig.c_builtins.__builtin_truncf;
pub const __builtin_round = @import("std").zig.c_builtins.__builtin_round;
pub const __builtin_roundf = @import("std").zig.c_builtins.__builtin_roundf;
pub const __builtin_strlen = @import("std").zig.c_builtins.__builtin_strlen;
pub const __builtin_strcmp = @import("std").zig.c_builtins.__builtin_strcmp;
pub const __builtin_object_size = @import("std").zig.c_builtins.__builtin_object_size;
pub const __builtin___memset_chk = @import("std").zig.c_builtins.__builtin___memset_chk;
pub const __builtin_memset = @import("std").zig.c_builtins.__builtin_memset;
pub const __builtin___memcpy_chk = @import("std").zig.c_builtins.__builtin___memcpy_chk;
pub const __builtin_memcpy = @import("std").zig.c_builtins.__builtin_memcpy;
pub const __builtin_expect = @import("std").zig.c_builtins.__builtin_expect;
pub const __builtin_nanf = @import("std").zig.c_builtins.__builtin_nanf;
pub const __builtin_huge_valf = @import("std").zig.c_builtins.__builtin_huge_valf;
pub const __builtin_inff = @import("std").zig.c_builtins.__builtin_inff;
pub const __builtin_isnan = @import("std").zig.c_builtins.__builtin_isnan;
pub const __builtin_isinf = @import("std").zig.c_builtins.__builtin_isinf;
pub const __builtin_isinf_sign = @import("std").zig.c_builtins.__builtin_isinf_sign;
pub const __has_builtin = @import("std").zig.c_builtins.__has_builtin;
pub const __builtin_assume = @import("std").zig.c_builtins.__builtin_assume;
pub const __builtin_unreachable = @import("std").zig.c_builtins.__builtin_unreachable;
pub const __builtin_constant_p = @import("std").zig.c_builtins.__builtin_constant_p;
pub const __builtin_mul_overflow = @import("std").zig.c_builtins.__builtin_mul_overflow;
pub const __builtin_va_list = [*c]u8;
pub const __gnuc_va_list = __builtin_va_list;
pub const va_list = __gnuc_va_list;
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:604:3: warning: TODO implement translation of stmt class GCCAsmStmtClass

// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:599:36: warning: unable to translate function, demoted to extern
pub extern fn __debugbreak() void;
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:626:3: warning: TODO implement translation of stmt class GCCAsmStmtClass

// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:620:60: warning: unable to translate function, demoted to extern
pub extern fn __fastfail(arg_code: c_uint) noreturn;
pub extern fn __mingw_get_crt_info() [*c]const u8;
pub const rsize_t = usize;
pub const ptrdiff_t = c_longlong;
pub const wchar_t = c_ushort;
pub const wint_t = c_ushort;
pub const wctype_t = c_ushort;
pub const errno_t = c_int;
pub const __time32_t = c_long;
pub const __time64_t = c_longlong;
pub const time_t = __time64_t;
pub const struct_threadlocaleinfostruct = extern struct {
    _locale_pctype: [*c]const c_ushort = @import("std").mem.zeroes([*c]const c_ushort),
    _locale_mb_cur_max: c_int = @import("std").mem.zeroes(c_int),
    _locale_lc_codepage: c_uint = @import("std").mem.zeroes(c_uint),
};
pub const struct_threadmbcinfostruct = opaque {};
pub const pthreadlocinfo = [*c]struct_threadlocaleinfostruct;
pub const pthreadmbcinfo = ?*struct_threadmbcinfostruct;
pub const struct___lc_time_data = opaque {};
pub const struct_localeinfo_struct = extern struct {
    locinfo: pthreadlocinfo = @import("std").mem.zeroes(pthreadlocinfo),
    mbcinfo: pthreadmbcinfo = @import("std").mem.zeroes(pthreadmbcinfo),
};
pub const _locale_tstruct = struct_localeinfo_struct;
pub const _locale_t = [*c]struct_localeinfo_struct;
pub const struct_tagLC_ID = extern struct {
    wLanguage: c_ushort = @import("std").mem.zeroes(c_ushort),
    wCountry: c_ushort = @import("std").mem.zeroes(c_ushort),
    wCodePage: c_ushort = @import("std").mem.zeroes(c_ushort),
};
pub const LC_ID = struct_tagLC_ID;
pub const LPLC_ID = [*c]struct_tagLC_ID;
pub const threadlocinfo = struct_threadlocaleinfostruct;
pub const int_least8_t = i8;
pub const uint_least8_t = u8;
pub const int_least16_t = c_short;
pub const uint_least16_t = c_ushort;
pub const int_least32_t = c_int;
pub const uint_least32_t = c_uint;
pub const int_least64_t = c_longlong;
pub const uint_least64_t = c_ulonglong;
pub const int_fast8_t = i8;
pub const uint_fast8_t = u8;
pub const int_fast16_t = c_short;
pub const uint_fast16_t = c_ushort;
pub const int_fast32_t = c_int;
pub const uint_fast32_t = c_uint;
pub const int_fast64_t = c_longlong;
pub const uint_fast64_t = c_ulonglong;
pub const intmax_t = c_longlong;
pub const uintmax_t = c_ulonglong;
pub const uint = c_uint;
pub const eint = c_uint;
pub const ushort = c_ushort;
pub const eshort = c_ushort;
pub const @"u8" = u8;
pub const byte = u8;
pub const uchar = u8;
pub const echar = u8;
pub const @"u16" = u16;
pub const hword = u16;
pub const @"u32" = u32;
pub const word = u32;
pub const @"u64" = u64;
pub const s8 = i8;
pub const s16 = i16;
pub const s32 = i32;
pub const s64 = i64;
pub const vu8 = @"u8";
pub const vu16 = @"u16";
pub const vu32 = @"u32";
pub const vu64 = @"u64";
pub const vs8 = s8;
pub const vs16 = s16;
pub const vs32 = s32;
pub const vs64 = s64;
pub const cu8 = @"u8";
pub const cu16 = @"u16";
pub const cu32 = @"u32";
pub const cu64 = @"u64";
pub const cs8 = s8;
pub const cs16 = s16;
pub const cs32 = s32;
pub const cs64 = s64;
pub const BLOCK = extern struct {
    data: [8]@"u32" = @import("std").mem.zeroes([8]@"u32"),
};
pub const CSTR = [*c]const u8;
pub const FIXED = s32;
pub const COLOR = @"u16";
pub const SCR_ENTRY = @"u16";
pub const SE = @"u16";
pub const SCR_AFF_ENTRY = @"u8";
pub const SAE = @"u8";
pub const TILE = extern struct {
    data: [8]@"u32" = @import("std").mem.zeroes([8]@"u32"),
};
pub const TILE4 = TILE;
pub const TILE8 = extern struct {
    data: [16]@"u32" = @import("std").mem.zeroes([16]@"u32"),
};
pub const BOOL = @"u8";
pub const fnptr = ?*const fn () callconv(.c) void;
pub const fn_v_i = ?*const fn (c_int) callconv(.c) void;
pub const fn_i_i = ?*const fn (c_int) callconv(.c) c_int;
pub const struct_AFF_SRC = extern struct {
    sx: s16 = @import("std").mem.zeroes(s16),
    sy: s16 = @import("std").mem.zeroes(s16),
    alpha: @"u16" = @import("std").mem.zeroes(@"u16"),
};
pub const AFF_SRC = struct_AFF_SRC;
pub const ObjAffineSource = struct_AFF_SRC;
pub const struct_AFF_SRC_EX = extern struct {
    tex_x: s32 = @import("std").mem.zeroes(s32),
    tex_y: s32 = @import("std").mem.zeroes(s32),
    scr_x: s16 = @import("std").mem.zeroes(s16),
    scr_y: s16 = @import("std").mem.zeroes(s16),
    sx: s16 = @import("std").mem.zeroes(s16),
    sy: s16 = @import("std").mem.zeroes(s16),
    alpha: @"u16" = @import("std").mem.zeroes(@"u16"),
};
pub const AFF_SRC_EX = struct_AFF_SRC_EX;
pub const BgAffineSource = struct_AFF_SRC_EX;
pub const struct_AFF_DST = extern struct {
    pa: s16 = @import("std").mem.zeroes(s16),
    pb: s16 = @import("std").mem.zeroes(s16),
    pc: s16 = @import("std").mem.zeroes(s16),
    pd: s16 = @import("std").mem.zeroes(s16),
};
pub const AFF_DST = struct_AFF_DST;
pub const ObjAffineDest = struct_AFF_DST;
pub const struct_AFF_DST_EX = extern struct {
    pa: s16 = @import("std").mem.zeroes(s16),
    pb: s16 = @import("std").mem.zeroes(s16),
    pc: s16 = @import("std").mem.zeroes(s16),
    pd: s16 = @import("std").mem.zeroes(s16),
    dx: s32 = @import("std").mem.zeroes(s32),
    dy: s32 = @import("std").mem.zeroes(s32),
};
pub const AFF_DST_EX = struct_AFF_DST_EX;
pub const BgAffineDest = struct_AFF_DST_EX;
pub const struct_POINT16 = extern struct {
    x: s16 = @import("std").mem.zeroes(s16),
    y: s16 = @import("std").mem.zeroes(s16),
};
pub const POINT16 = struct_POINT16;
pub const BG_POINT = struct_POINT16;
pub const BG_AFFINE = struct_AFF_DST_EX;
pub const struct_DMA_REC = extern struct {
    src: ?*const anyopaque = @import("std").mem.zeroes(?*const anyopaque),
    dst: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    cnt: @"u32" = @import("std").mem.zeroes(@"u32"),
};
pub const DMA_REC = struct_DMA_REC;
const union_unnamed_1 = extern union {
    start: @"u16" align(1),
    count: @"u16" align(1),
};
pub const struct_TMR_REC = extern struct {
    unnamed_0: union_unnamed_1 = @import("std").mem.zeroes(union_unnamed_1),
    cnt: @"u16" = @import("std").mem.zeroes(@"u16"),
};
pub const TMR_REC = struct_TMR_REC;
pub const PALBANK = [16]COLOR;
pub const SCREENLINE = [32]SCR_ENTRY;
pub const SCREENMAT = [32][32]SCR_ENTRY;
pub const SCREENBLOCK = [1024]SCR_ENTRY;
pub const M3LINE = [240]COLOR;
pub const M4LINE = [240]@"u8";
pub const M5LINE = [160]COLOR;
pub const CHARBLOCK = [512]TILE;
pub const CHARBLOCK8 = [256]TILE8;
pub const struct_OBJ_ATTR = extern struct {
    attr0: @"u16" = @import("std").mem.zeroes(@"u16"),
    attr1: @"u16" = @import("std").mem.zeroes(@"u16"),
    attr2: @"u16" = @import("std").mem.zeroes(@"u16"),
    fill: s16 = @import("std").mem.zeroes(s16),
};
pub const OBJ_ATTR = struct_OBJ_ATTR;
pub const struct_OBJ_AFFINE = extern struct {
    fill0: [3]@"u16" = @import("std").mem.zeroes([3]@"u16"),
    pa: s16 = @import("std").mem.zeroes(s16),
    fill1: [3]@"u16" = @import("std").mem.zeroes([3]@"u16"),
    pb: s16 = @import("std").mem.zeroes(s16),
    fill2: [3]@"u16" = @import("std").mem.zeroes([3]@"u16"),
    pc: s16 = @import("std").mem.zeroes(s16),
    fill3: [3]@"u16" = @import("std").mem.zeroes([3]@"u16"),
    pd: s16 = @import("std").mem.zeroes(s16),
};
pub const OBJ_AFFINE = struct_OBJ_AFFINE;
pub fn bf_get(arg_y: @"u32", arg_shift: uint, arg_len: uint) callconv(.c) @"u32" {
    var y = arg_y;
    _ = &y;
    var shift = arg_shift;
    _ = &shift;
    var len = arg_len;
    _ = &len;
    return (y >> @intCast(shift)) & @as(@"u32", @bitCast((@as(c_int, 1) << @intCast(len)) - @as(c_int, 1)));
}
pub fn bf_merge(arg_y: @"u32", arg_x: @"u32", arg_shift: uint, arg_len: uint) callconv(.c) @"u32" {
    var y = arg_y;
    _ = &y;
    var x = arg_x;
    _ = &x;
    var shift = arg_shift;
    _ = &shift;
    var len = arg_len;
    _ = &len;
    var mask: @"u32" = @as(@"u32", @bitCast(@as(c_int, 1) << @intCast(len))) -% @as(@"u32", @bitCast(@as(c_int, 1)));
    _ = &mask;
    return (y & ~(mask << @intCast(shift))) | ((x & mask) << @intCast(shift));
}
pub fn bf_clamp(arg_x: c_int, arg_len: uint) callconv(.c) @"u32" {
    var x = arg_x;
    _ = &x;
    var len = arg_len;
    _ = &len;
    var y: @"u32" = @as(@"u32", @bitCast(x >> @intCast(len)));
    _ = &y;
    if (y != 0) {
        x = @as(c_int, @bitCast(~y >> @intCast(@as(uint, @bitCast(@as(c_int, 32))) -% len)));
    }
    return @as(@"u32", @bitCast(x));
}
pub fn bit_tribool(arg_flags: @"u32", arg_plus: uint, arg_minus: uint) callconv(.c) c_int {
    var flags = arg_flags;
    _ = &flags;
    var plus = arg_plus;
    _ = &plus;
    var minus = arg_minus;
    _ = &minus;
    return @as(c_int, @bitCast(((flags >> @intCast(plus)) & @as(@"u32", @bitCast(@as(c_int, 1)))) -% ((flags >> @intCast(minus)) & @as(@"u32", @bitCast(@as(c_int, 1))))));
}
pub fn ROR(arg_x: @"u32", arg_ror: uint) callconv(.c) @"u32" {
    var x = arg_x;
    _ = &x;
    var ror = arg_ror;
    _ = &ror;
    return (x << @intCast(@as(uint, @bitCast(@as(c_int, 32))) -% ror)) | (x >> @intCast(ror));
}
pub fn @"align"(arg_x: uint, arg_width: uint) callconv(.c) uint {
    var x = arg_x;
    _ = &x;
    var width = arg_width;
    _ = &width;
    return (((x +% width) -% @as(uint, @bitCast(@as(c_int, 1)))) / width) *% width;
}
pub extern fn tonccpy(dst: ?*anyopaque, src: ?*const anyopaque, size: uint) ?*anyopaque;
pub extern fn __toncset(dst: ?*anyopaque, fill: @"u32", size: uint) ?*anyopaque;
pub fn toncset(arg_dst: ?*anyopaque, arg_src: @"u8", arg_count: uint) callconv(.c) ?*anyopaque {
    var dst = arg_dst;
    _ = &dst;
    var src = arg_src;
    _ = &src;
    var count = arg_count;
    _ = &count;
    return __toncset(dst, quad8(src), count);
}
pub fn toncset16(arg_dst: ?*anyopaque, arg_src: @"u16", arg_count: uint) callconv(.c) ?*anyopaque {
    var dst = arg_dst;
    _ = &dst;
    var src = arg_src;
    _ = &src;
    var count = arg_count;
    _ = &count;
    return __toncset(dst, @as(@"u32", @bitCast(@as(c_int, @bitCast(@as(c_uint, src))) | (@as(c_int, @bitCast(@as(c_uint, src))) << @intCast(16)))), count *% @as(uint, @bitCast(@as(c_int, 2))));
}
pub fn toncset32(arg_dst: ?*anyopaque, arg_src: @"u32", arg_count: uint) callconv(.c) ?*anyopaque {
    var dst = arg_dst;
    _ = &dst;
    var src = arg_src;
    _ = &src;
    var count = arg_count;
    _ = &count;
    return __toncset(dst, src, count *% @as(uint, @bitCast(@as(c_int, 4))));
}
pub extern fn memset16(dst: ?*anyopaque, hw: @"u16", hwcount: uint) void;
pub extern fn memcpy16(dst: ?*anyopaque, src: ?*const anyopaque, hwcount: uint) void;
pub extern fn memset32(dst: ?*anyopaque, wd: @"u32", wcount: uint) linksection(".iwram") void;
pub extern fn memcpy32(dst: ?*anyopaque, src: ?*const anyopaque, wcount: uint) linksection(".iwram") void;
pub fn dup8(arg_x: @"u8") callconv(.c) @"u16" {
    var x = arg_x;
    _ = &x;
    return @as(@"u16", @bitCast(@as(c_short, @truncate(@as(c_int, @bitCast(@as(c_uint, x))) | (@as(c_int, @bitCast(@as(c_uint, x))) << @intCast(8))))));
}
pub fn dup16(arg_x: @"u16") callconv(.c) @"u32" {
    var x = arg_x;
    _ = &x;
    return @as(@"u32", @bitCast(@as(c_int, @bitCast(@as(c_uint, x))) | (@as(c_int, @bitCast(@as(c_uint, x))) << @intCast(16))));
}
pub fn quad8(arg_x: @"u8") callconv(.c) @"u32" {
    var x = arg_x;
    _ = &x;
    return @as(@"u32", @bitCast(@as(c_int, @bitCast(@as(c_uint, x))) * @as(c_int, 16843009)));
}
pub fn octup(arg_x: @"u8") callconv(.c) @"u32" {
    var x = arg_x;
    _ = &x;
    return @as(@"u32", @bitCast(@as(c_int, @bitCast(@as(c_uint, x))) * @as(c_int, 286331153)));
}
pub fn bytes2hword(arg_b0: @"u8", arg_b1: @"u8") callconv(.c) @"u16" {
    var b0 = arg_b0;
    _ = &b0;
    var b1 = arg_b1;
    _ = &b1;
    return @as(@"u16", @bitCast(@as(c_short, @truncate(@as(c_int, @bitCast(@as(c_uint, b0))) | (@as(c_int, @bitCast(@as(c_uint, b1))) << @intCast(8))))));
}
pub fn bytes2word(arg_b0: @"u8", arg_b1: @"u8", arg_b2: @"u8", arg_b3: @"u8") callconv(.c) @"u32" {
    var b0 = arg_b0;
    _ = &b0;
    var b1 = arg_b1;
    _ = &b1;
    var b2 = arg_b2;
    _ = &b2;
    var b3 = arg_b3;
    _ = &b3;
    return @as(@"u32", @bitCast(((@as(c_int, @bitCast(@as(c_uint, b0))) | (@as(c_int, @bitCast(@as(c_uint, b1))) << @intCast(8))) | (@as(c_int, @bitCast(@as(c_uint, b2))) << @intCast(16))) | (@as(c_int, @bitCast(@as(c_uint, b3))) << @intCast(24))));
}
pub fn hword2word(arg_h0: @"u16", arg_h1: @"u16") callconv(.c) @"u32" {
    var h0 = arg_h0;
    _ = &h0;
    var h1 = arg_h1;
    _ = &h1;
    return @as(@"u32", @bitCast(@as(c_int, @bitCast(@as(c_uint, h0))) | (@as(c_int, @bitCast(@as(c_uint, h1))) << @intCast(16))));
}
pub fn dma_cpy(arg_dst: ?*anyopaque, arg_src: ?*const anyopaque, arg_count: uint, arg_ch: uint, arg_mode: @"u32") callconv(.c) void {
    var dst = arg_dst;
    _ = &dst;
    var src = arg_src;
    _ = &src;
    var count = arg_count;
    _ = &count;
    var ch = arg_ch;
    _ = &ch;
    var mode = arg_mode;
    _ = &mode;
    @as([*c]volatile DMA_REC, @ptrFromInt(@as(c_int, 67108864) + @as(c_int, 176)))[ch].cnt = 0;
    @as([*c]volatile DMA_REC, @ptrFromInt(@as(c_int, 67108864) + @as(c_int, 176)))[ch].src = src;
    @as([*c]volatile DMA_REC, @ptrFromInt(@as(c_int, 67108864) + @as(c_int, 176)))[ch].dst = dst;
    @as([*c]volatile DMA_REC, @ptrFromInt(@as(c_int, 67108864) + @as(c_int, 176)))[ch].cnt = mode | count;
}
pub fn dma_fill(arg_dst: ?*anyopaque, arg_src: @"u32", arg_count: uint, arg_ch: uint, arg_mode: @"u32") callconv(.c) void {
    var dst = arg_dst;
    _ = &dst;
    var src = arg_src;
    _ = &src;
    var count = arg_count;
    _ = &count;
    var ch = arg_ch;
    _ = &ch;
    var mode = arg_mode;
    _ = &mode;
    @as([*c]volatile DMA_REC, @ptrFromInt(@as(c_int, 67108864) + @as(c_int, 176)))[ch].cnt = 0;
    @as([*c]volatile DMA_REC, @ptrFromInt(@as(c_int, 67108864) + @as(c_int, 176)))[ch].src = @as(?*const anyopaque, @ptrCast(@volatileCast(@constCast(&src))));
    @as([*c]volatile DMA_REC, @ptrFromInt(@as(c_int, 67108864) + @as(c_int, 176)))[ch].dst = dst;
    @as([*c]volatile DMA_REC, @ptrFromInt(@as(c_int, 67108864) + @as(c_int, 176)))[ch].cnt = (count | mode) | @as(c_uint, @bitCast(@as(c_int, 16777216)));
}
pub fn dma3_cpy(arg_dst: ?*anyopaque, arg_src: ?*const anyopaque, arg_size: uint) callconv(.c) void {
    var dst = arg_dst;
    _ = &dst;
    var src = arg_src;
    _ = &src;
    var size = arg_size;
    _ = &size;
    dma_cpy(dst, src, size / @as(uint, @bitCast(@as(c_int, 4))), @as(uint, @bitCast(@as(c_int, 3))), (@as(c_uint, 2147483648) | @as(c_uint, @bitCast(@as(c_int, 0)))) | @as(c_uint, @bitCast(@as(c_int, 67108864))));
}
pub fn dma3_fill(arg_dst: ?*anyopaque, arg_src: @"u32", arg_size: uint) callconv(.c) void {
    var dst = arg_dst;
    _ = &dst;
    var src = arg_src;
    _ = &src;
    var size = arg_size;
    _ = &size;
    dma_fill(dst, src, size / @as(uint, @bitCast(@as(c_int, 4))), @as(uint, @bitCast(@as(c_int, 3))), ((@as(c_uint, 2147483648) | @as(c_uint, @bitCast(@as(c_int, 0)))) | @as(c_uint, @bitCast(@as(c_int, 16777216)))) | @as(c_uint, @bitCast(@as(c_int, 67108864))));
}
pub fn profile_start() callconv(.c) void {
    @as([*c]volatile vu16, @ptrFromInt(@as(c_int, 67108864) + @as(c_int, 264))).* = 0;
    @as([*c]volatile vu16, @ptrFromInt(@as(c_int, 67108864) + @as(c_int, 268))).* = 0;
    @as([*c]volatile vu16, @ptrFromInt(@as(c_int, 67108864) + @as(c_int, 266))).* = 0;
    @as([*c]volatile vu16, @ptrFromInt(@as(c_int, 67108864) + @as(c_int, 270))).* = 0;
    @as([*c]volatile vu16, @ptrFromInt(@as(c_int, 67108864) + @as(c_int, 270))).* = @as(@"u16", @bitCast(@as(c_short, @truncate(@as(c_int, 128) | @as(c_int, 4)))));
    @as([*c]volatile vu16, @ptrFromInt(@as(c_int, 67108864) + @as(c_int, 266))).* = 128;
}
pub fn profile_stop() callconv(.c) uint {
    @as([*c]volatile vu16, @ptrFromInt(@as(c_int, 67108864) + @as(c_int, 266))).* = 0;
    return @as(uint, @bitCast((@as(c_int, @bitCast(@as(c_uint, @as([*c]volatile vu16, @ptrFromInt(@as(c_int, 67108864) + @as(c_int, 268))).*))) << @intCast(16)) | @as(c_int, @bitCast(@as(c_uint, @as([*c]volatile vu16, @ptrFromInt(@as(c_int, 67108864) + @as(c_int, 264))).*)))));
}
pub const NOTE_C: c_int = 0;
pub const NOTE_CIS: c_int = 1;
pub const NOTE_D: c_int = 2;
pub const NOTE_DIS: c_int = 3;
pub const NOTE_E: c_int = 4;
pub const NOTE_F: c_int = 5;
pub const NOTE_FIS: c_int = 6;
pub const NOTE_G: c_int = 7;
pub const NOTE_GIS: c_int = 8;
pub const NOTE_A: c_int = 9;
pub const NOTE_BES: c_int = 10;
pub const NOTE_B: c_int = 11;
pub const eSndNoteId = c_uint;
pub extern const __snd_rates: [12]uint;
pub extern fn octant(x: c_int, y: c_int) @"u32";
pub extern fn octant_rot(x0: c_int, y0: c_int) @"u32";
pub extern fn sqran(seed: c_int) c_int;
pub fn qran() callconv(.c) c_int {
    __qran_seed = (@as(c_int, 1664525) * __qran_seed) + @as(c_int, 1013904223);
    return (__qran_seed >> @intCast(16)) & ((@as(c_int, 1) << @intCast(15)) - @as(c_int, 1));
}
pub fn qran_range(arg_min_1: c_int, arg_max_2: c_int) callconv(.c) c_int {
    var min_1 = arg_min_1;
    _ = &min_1;
    var max_2 = arg_max_2;
    _ = &max_2;
    return ((qran() * (max_2 - min_1)) >> @intCast(15)) + min_1;
}
pub extern const oam_sizes: [3][4][2]@"u8";
pub extern const bg_aff_default: BG_AFFINE;
pub extern var vid_page: [*c]COLOR;
pub extern var __qran_seed: c_int;
pub fn vid_vsync() callconv(.c) void {
    while (@as(c_int, @bitCast(@as(c_uint, @as([*c]volatile vu16, @ptrFromInt(@as(c_int, 67108864) + @as(c_int, 6))).*))) >= @as(c_int, 160)) {}
    while (@as(c_int, @bitCast(@as(c_uint, @as([*c]volatile vu16, @ptrFromInt(@as(c_int, 67108864) + @as(c_int, 6))).*))) < @as(c_int, 160)) {}
}
pub extern fn vid_wait(frames: uint) void;
pub extern fn vid_flip() [*c]@"u16";
pub export fn clr_rotate(arg_clrs: [*c]COLOR, arg_nclrs: uint, arg_ror: c_int) void {
    var clrs = arg_clrs;
    _ = &clrs;
    var nclrs = arg_nclrs;
    _ = &nclrs;
    var ror = arg_ror;
    _ = &ror;
    if (ror == @as(c_int, 0)) return;
    var ii: c_int = undefined;
    _ = &ii;
    var jj: c_int = undefined;
    _ = &jj;
    var rot: c_int = undefined;
    _ = &rot;
    var tmp: @"u32" = undefined;
    _ = &tmp;
    if (ror > @as(c_int, 0)) {
        rot = ror;
        if (@as(uint, @bitCast(rot)) > nclrs) {
            rot = Mod(rot, @as(c_int, @bitCast(nclrs)));
        }
        {
            ii = 0;
            while (ii < rot) : (ii += 1) {
                tmp = @as(@"u32", @bitCast(@as(c_uint, clrs[nclrs -% @as(uint, @bitCast(@as(c_int, 1)))])));
                {
                    jj = @as(c_int, @bitCast(nclrs -% @as(uint, @bitCast(@as(c_int, 1)))));
                    while (jj > @as(c_int, 0)) : (jj -= 1) {
                        (blk: {
                            const tmp_1 = jj;
                            if (tmp_1 >= 0) break :blk clrs + @as(usize, @intCast(tmp_1)) else break :blk clrs - ~@as(usize, @bitCast(@as(isize, @intCast(tmp_1)) +% -1));
                        }).* = (blk: {
                            const tmp_1 = jj - @as(c_int, 1);
                            if (tmp_1 >= 0) break :blk clrs + @as(usize, @intCast(tmp_1)) else break :blk clrs - ~@as(usize, @bitCast(@as(isize, @intCast(tmp_1)) +% -1));
                        }).*;
                    }
                }
                clrs[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(COLOR, @bitCast(@as(c_ushort, @truncate(tmp))));
            }
        }
    } else {
        rot = @as(c_int, @bitCast(nclrs -% @as(uint, @bitCast(ror))));
        if (@as(uint, @bitCast(rot)) > nclrs) {
            rot = Mod(rot, @as(c_int, @bitCast(nclrs)));
        }
        {
            ii = 0;
            while (ii < rot) : (ii += 1) {
                tmp = @as(@"u32", @bitCast(@as(c_uint, clrs[@as(c_uint, @intCast(@as(c_int, 0)))])));
                {
                    jj = 0;
                    while (@as(uint, @bitCast(jj)) < (nclrs -% @as(uint, @bitCast(@as(c_int, 1))))) : (jj += 1) {
                        (blk: {
                            const tmp_1 = jj;
                            if (tmp_1 >= 0) break :blk clrs + @as(usize, @intCast(tmp_1)) else break :blk clrs - ~@as(usize, @bitCast(@as(isize, @intCast(tmp_1)) +% -1));
                        }).* = (blk: {
                            const tmp_1 = jj + @as(c_int, 1);
                            if (tmp_1 >= 0) break :blk clrs + @as(usize, @intCast(tmp_1)) else break :blk clrs - ~@as(usize, @bitCast(@as(isize, @intCast(tmp_1)) +% -1));
                        }).*;
                    }
                }
                clrs[nclrs -% @as(uint, @bitCast(@as(c_int, 1)))] = @as(COLOR, @bitCast(@as(c_ushort, @truncate(tmp))));
            }
        }
    }
}
pub export fn clr_blend(arg_srca: [*c]const COLOR, arg_srcb: [*c]const COLOR, arg_dst: [*c]COLOR, arg_nclrs: uint, arg_alpha: @"u32") void {
    var srca = arg_srca;
    _ = &srca;
    var srcb = arg_srcb;
    _ = &srcb;
    var dst = arg_dst;
    _ = &dst;
    var nclrs = arg_nclrs;
    _ = &nclrs;
    var alpha = arg_alpha;
    _ = &alpha;
    if (!(nclrs != 0)) return;
    var ii: c_int = undefined;
    _ = &ii;
    var clra: @"u32" = undefined;
    _ = &clra;
    var clrb: @"u32" = undefined;
    _ = &clrb;
    var clr: @"u32" = undefined;
    _ = &clr;
    var parta: @"u32" = undefined;
    _ = &parta;
    var partb: @"u32" = undefined;
    _ = &partb;
    var part: @"u32" = undefined;
    _ = &part;
    const rbmask: @"u32" = @as(@"u32", @bitCast(@as(c_int, 31) | @as(c_int, 31744)));
    _ = &rbmask;
    const gmask: @"u32" = @as(@"u32", @bitCast(@as(c_int, 992)));
    _ = &gmask;
    const rbhalf: @"u32" = @as(@"u32", @bitCast(@as(c_int, 16400)));
    _ = &rbhalf;
    const ghalf: @"u32" = @as(@"u32", @bitCast(@as(c_int, 512)));
    _ = &ghalf;
    {
        ii = 0;
        while (@as(uint, @bitCast(ii)) < nclrs) : (ii += 1) {
            clra = @as(@"u32", @bitCast(@as(c_uint, (blk: {
                const tmp = ii;
                if (tmp >= 0) break :blk srca + @as(usize, @intCast(tmp)) else break :blk srca - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*)));
            clrb = @as(@"u32", @bitCast(@as(c_uint, (blk: {
                const tmp = ii;
                if (tmp >= 0) break :blk srcb + @as(usize, @intCast(tmp)) else break :blk srcb - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*)));
            parta = clra & rbmask;
            partb = clrb & rbmask;
            part = (((partb -% parta) *% alpha) +% (parta *% @as(@"u32", @bitCast(@as(c_int, 32))))) +% rbhalf;
            clr = (part / @as(@"u32", @bitCast(@as(c_int, 32)))) & rbmask;
            parta = clra & gmask;
            partb = clrb & gmask;
            part = (((partb -% parta) *% alpha) +% (parta *% @as(@"u32", @bitCast(@as(c_int, 32))))) +% ghalf;
            clr |= (part / @as(@"u32", @bitCast(@as(c_int, 32)))) & gmask;
            (blk: {
                const tmp = ii;
                if (tmp >= 0) break :blk dst + @as(usize, @intCast(tmp)) else break :blk dst - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = @as(COLOR, @bitCast(@as(c_ushort, @truncate(clr))));
        }
    }
}
pub export fn clr_fade(arg_src: [*c]const COLOR, arg_clr: COLOR, arg_dst: [*c]COLOR, arg_nclrs: uint, arg_alpha: @"u32") void {
    var src = arg_src;
    _ = &src;
    var clr = arg_clr;
    _ = &clr;
    var dst = arg_dst;
    _ = &dst;
    var nclrs = arg_nclrs;
    _ = &nclrs;
    var alpha = arg_alpha;
    _ = &alpha;
    if (!(nclrs != 0)) return;
    var ii: c_int = undefined;
    _ = &ii;
    var clra: @"u32" = undefined;
    _ = &clra;
    var parta: @"u32" = undefined;
    _ = &parta;
    var part: @"u32" = undefined;
    _ = &part;
    const rbmask: @"u32" = @as(@"u32", @bitCast(@as(c_int, 31) | @as(c_int, 31744)));
    _ = &rbmask;
    const gmask: @"u32" = @as(@"u32", @bitCast(@as(c_int, 992)));
    _ = &gmask;
    const rbhalf: @"u32" = @as(@"u32", @bitCast(@as(c_int, 16400)));
    _ = &rbhalf;
    const ghalf: @"u32" = @as(@"u32", @bitCast(@as(c_int, 512)));
    _ = &ghalf;
    var partb_rb: @"u32" = @as(@"u32", @bitCast(@as(c_uint, clr))) & rbmask;
    _ = &partb_rb;
    var partb_g: @"u32" = @as(@"u32", @bitCast(@as(c_uint, clr))) & gmask;
    _ = &partb_g;
    {
        ii = 0;
        while (@as(uint, @bitCast(ii)) < nclrs) : (ii += 1) {
            clra = @as(@"u32", @bitCast(@as(c_uint, (blk: {
                const tmp = ii;
                if (tmp >= 0) break :blk src + @as(usize, @intCast(tmp)) else break :blk src - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*)));
            parta = clra & rbmask;
            part = (((partb_rb -% parta) *% alpha) +% (parta *% @as(@"u32", @bitCast(@as(c_int, 32))))) +% rbhalf;
            clr = @as(COLOR, @bitCast(@as(c_ushort, @truncate((part / @as(@"u32", @bitCast(@as(c_int, 32)))) & rbmask))));
            parta = clra & gmask;
            part = (((partb_g -% parta) *% alpha) +% (parta *% @as(@"u32", @bitCast(@as(c_int, 32))))) +% ghalf;
            clr |= @as(COLOR, @bitCast(@as(c_ushort, @truncate((part / @as(@"u32", @bitCast(@as(c_int, 32)))) & gmask))));
            (blk: {
                const tmp = ii;
                if (tmp >= 0) break :blk dst + @as(usize, @intCast(tmp)) else break :blk dst - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = clr;
        }
    }
}
pub export fn clr_grayscale(arg_dst: [*c]COLOR, arg_src: [*c]const COLOR, arg_nclrs: uint) void {
    var dst = arg_dst;
    _ = &dst;
    var src = arg_src;
    _ = &src;
    var nclrs = arg_nclrs;
    _ = &nclrs;
    var ii: @"u32" = undefined;
    _ = &ii;
    var clr: @"u32" = undefined;
    _ = &clr;
    var gray: @"u32" = undefined;
    _ = &gray;
    var rr: @"u32" = undefined;
    _ = &rr;
    var gg: @"u32" = undefined;
    _ = &gg;
    var bb: @"u32" = undefined;
    _ = &bb;
    {
        ii = 0;
        while (ii < nclrs) : (ii +%= 1) {
            clr = @as(@"u32", @bitCast(@as(c_uint, (blk: {
                const ref = &src;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).*)));
            rr = (clr & @as(@"u32", @bitCast(@as(c_int, 31)))) *% @as(@"u32", @bitCast(@as(c_int, 76)));
            gg = ((clr >> @intCast(5)) & @as(@"u32", @bitCast(@as(c_int, 31)))) *% @as(@"u32", @bitCast(@as(c_int, 150)));
            bb = ((clr >> @intCast(10)) & @as(@"u32", @bitCast(@as(c_int, 31)))) *% @as(@"u32", @bitCast(@as(c_int, 30)));
            gray = (((rr +% gg) +% bb) +% @as(@"u32", @bitCast(@as(c_int, 128)))) >> @intCast(8);
            (blk: {
                const ref = &dst;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).* = RGB15(@as(c_int, @bitCast(gray)), @as(c_int, @bitCast(gray)), @as(c_int, @bitCast(gray)));
        }
    }
}
pub export fn clr_rgbscale(arg_dst: [*c]COLOR, arg_src: [*c]const COLOR, arg_nclrs: uint, arg_clr: COLOR) void {
    var dst = arg_dst;
    _ = &dst;
    var src = arg_src;
    _ = &src;
    var nclrs = arg_nclrs;
    _ = &nclrs;
    var clr = arg_clr;
    _ = &clr;
    var ii: c_int = undefined;
    _ = &ii;
    var rr: @"u32" = undefined;
    _ = &rr;
    var gg: @"u32" = undefined;
    _ = &gg;
    var bb: @"u32" = undefined;
    _ = &bb;
    var scale: @"u32" = undefined;
    _ = &scale;
    var gray: @"u32" = undefined;
    _ = &gray;
    rr = @as(@"u32", @bitCast(@as(c_int, @bitCast(@as(c_uint, clr))) & @as(c_int, 31)));
    gg = @as(@"u32", @bitCast((@as(c_int, @bitCast(@as(c_uint, clr))) >> @intCast(5)) & @as(c_int, 31)));
    bb = @as(@"u32", @bitCast((@as(c_int, @bitCast(@as(c_uint, clr))) >> @intCast(10)) & @as(c_int, 31)));
    scale = @as(@"u32", @bitCast(max(max(@as(c_int, @bitCast(rr)), @as(c_int, @bitCast(gg))), @as(c_int, @bitCast(bb)))));
    if (scale == @as(@"u32", @bitCast(@as(c_int, 0)))) {
        clr_grayscale(dst, src, nclrs);
        return;
    }
    scale = lu_div(scale);
    rr *%= scale;
    gg *%= scale;
    bb *%= scale;
    {
        ii = 0;
        while (@as(uint, @bitCast(ii)) < nclrs) : (ii += 1) {
            clr = (blk: {
                const ref = &src;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).*;
            gray = @as(@"u32", @bitCast((@as(c_int, @bitCast(@as(c_uint, clr))) & @as(c_int, 31)) * @as(c_int, 76)));
            gray +%= @as(@"u32", @bitCast(((@as(c_int, @bitCast(@as(c_uint, clr))) >> @intCast(5)) & @as(c_int, 31)) * @as(c_int, 150)));
            gray +%= @as(@"u32", @bitCast(((@as(c_int, @bitCast(@as(c_uint, clr))) >> @intCast(10)) & @as(c_int, 31)) * @as(c_int, 30)));
            (blk: {
                const tmp = ii;
                if (tmp >= 0) break :blk dst + @as(usize, @intCast(tmp)) else break :blk dst - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = RGB15(@as(c_int, @bitCast((rr *% gray) >> @intCast(24))), @as(c_int, @bitCast((gg *% gray) >> @intCast(24))), @as(c_int, @bitCast((bb *% gray) >> @intCast(24))));
        }
    }
}
pub export fn clr_adj_brightness(arg_dst: [*c]COLOR, arg_src: [*c]const COLOR, arg_nclrs: uint, arg_bright: FIXED) void {
    var dst = arg_dst;
    _ = &dst;
    var src = arg_src;
    _ = &src;
    var nclrs = arg_nclrs;
    _ = &nclrs;
    var bright = arg_bright;
    _ = &bright;
    var ii: @"u32" = undefined;
    _ = &ii;
    var clr: @"u32" = undefined;
    _ = &clr;
    var rr: c_int = undefined;
    _ = &rr;
    var gg: c_int = undefined;
    _ = &gg;
    var bb: c_int = undefined;
    _ = &bb;
    bright >>= @intCast(@as(c_int, 3));
    {
        ii = 0;
        while (ii < nclrs) : (ii +%= 1) {
            clr = @as(@"u32", @bitCast(@as(c_uint, src[ii])));
            rr = @as(c_int, @bitCast((clr & @as(@"u32", @bitCast(@as(c_int, 31)))) +% @as(@"u32", @bitCast(bright))));
            gg = @as(c_int, @bitCast(((clr >> @intCast(5)) & @as(@"u32", @bitCast(@as(c_int, 31)))) +% @as(@"u32", @bitCast(bright))));
            bb = @as(c_int, @bitCast(((clr >> @intCast(10)) & @as(@"u32", @bitCast(@as(c_int, 31)))) +% @as(@"u32", @bitCast(bright))));
            dst[ii] = RGB15(@as(c_int, @bitCast(bf_clamp(rr, @as(uint, @bitCast(@as(c_int, 5)))))), @as(c_int, @bitCast(bf_clamp(gg, @as(uint, @bitCast(@as(c_int, 5)))))), @as(c_int, @bitCast(bf_clamp(bb, @as(uint, @bitCast(@as(c_int, 5)))))));
        }
    }
}
pub export fn clr_adj_contrast(arg_dst: [*c]COLOR, arg_src: [*c]const COLOR, arg_nclrs: uint, arg_contrast: FIXED) void {
    var dst = arg_dst;
    _ = &dst;
    var src = arg_src;
    _ = &src;
    var nclrs = arg_nclrs;
    _ = &nclrs;
    var contrast = arg_contrast;
    _ = &contrast;
    var ii: @"u32" = undefined;
    _ = &ii;
    var clr: @"u32" = undefined;
    _ = &clr;
    var rr: c_int = undefined;
    _ = &rr;
    var gg: c_int = undefined;
    _ = &gg;
    var bb: c_int = undefined;
    _ = &bb;
    var ca: FIXED = contrast + (@as(c_int, 1) << @intCast(8));
    _ = &ca;
    var cb: FIXED = (-contrast >> @intCast(1)) * @as(c_int, 32);
    _ = &cb;
    {
        ii = 0;
        while (ii < nclrs) : (ii +%= 1) {
            clr = @as(@"u32", @bitCast(@as(c_uint, src[ii])));
            rr = @as(c_int, @bitCast((@as(@"u32", @bitCast(ca)) *% (clr & @as(@"u32", @bitCast(@as(c_int, 31))))) +% @as(@"u32", @bitCast(cb))));
            gg = @as(c_int, @bitCast((@as(@"u32", @bitCast(ca)) *% ((clr >> @intCast(5)) & @as(@"u32", @bitCast(@as(c_int, 31))))) +% @as(@"u32", @bitCast(cb))));
            bb = @as(c_int, @bitCast((@as(@"u32", @bitCast(ca)) *% ((clr >> @intCast(10)) & @as(@"u32", @bitCast(@as(c_int, 31))))) +% @as(@"u32", @bitCast(cb))));
            dst[ii] = RGB15(@as(c_int, @bitCast(bf_clamp(rr >> @intCast(8), @as(uint, @bitCast(@as(c_int, 5)))))), @as(c_int, @bitCast(bf_clamp(gg >> @intCast(8), @as(uint, @bitCast(@as(c_int, 5)))))), @as(c_int, @bitCast(bf_clamp(bb >> @intCast(8), @as(uint, @bitCast(@as(c_int, 5)))))));
        }
    }
}
pub export fn clr_adj_intensity(arg_dst: [*c]COLOR, arg_src: [*c]const COLOR, arg_nclrs: uint, arg_intensity: FIXED) void {
    var dst = arg_dst;
    _ = &dst;
    var src = arg_src;
    _ = &src;
    var nclrs = arg_nclrs;
    _ = &nclrs;
    var intensity = arg_intensity;
    _ = &intensity;
    var ii: @"u32" = undefined;
    _ = &ii;
    var clr: @"u32" = undefined;
    _ = &clr;
    var rr: c_int = undefined;
    _ = &rr;
    var gg: c_int = undefined;
    _ = &gg;
    var bb: c_int = undefined;
    _ = &bb;
    var ia: FIXED = intensity + (@as(c_int, 1) << @intCast(8));
    _ = &ia;
    {
        ii = 0;
        while (ii < nclrs) : (ii +%= 1) {
            clr = @as(@"u32", @bitCast(@as(c_uint, (blk: {
                const ref = &src;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).*)));
            rr = @as(c_int, @bitCast(@as(@"u32", @bitCast(ia)) *% (clr & @as(@"u32", @bitCast(@as(c_int, 31))))));
            gg = @as(c_int, @bitCast(@as(@"u32", @bitCast(ia)) *% ((clr >> @intCast(5)) & @as(@"u32", @bitCast(@as(c_int, 31))))));
            bb = @as(c_int, @bitCast(@as(@"u32", @bitCast(ia)) *% ((clr >> @intCast(10)) & @as(@"u32", @bitCast(@as(c_int, 31))))));
            (blk: {
                const ref = &dst;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).* = RGB15(@as(c_int, @bitCast(bf_clamp(rr >> @intCast(8), @as(uint, @bitCast(@as(c_int, 5)))))), @as(c_int, @bitCast(bf_clamp(gg >> @intCast(8), @as(uint, @bitCast(@as(c_int, 5)))))), @as(c_int, @bitCast(bf_clamp(bb >> @intCast(8), @as(uint, @bitCast(@as(c_int, 5)))))));
        }
    }
}
pub export fn pal_gradient(arg_pal: [*c]COLOR, arg_first: c_int, arg_last: c_int) void {
    var pal = arg_pal;
    _ = &pal;
    var first = arg_first;
    _ = &first;
    var last = arg_last;
    _ = &last;
    if (first > last) while (true) {
        first = first - last;
        last = first + last;
        first = last - first;
        if (!false) break;
    };
    if ((last - first) < @as(c_int, 2)) return;
    var ii: c_int = undefined;
    _ = &ii;
    var clra: COLOR = (blk: {
        const tmp = first;
        if (tmp >= 0) break :blk pal + @as(usize, @intCast(tmp)) else break :blk pal - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    _ = &clra;
    var clrb: COLOR = (blk: {
        const tmp = last;
        if (tmp >= 0) break :blk pal + @as(usize, @intCast(tmp)) else break :blk pal - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    _ = &clrb;
    var r: c_int = @as(c_int, @bitCast(@as(c_uint, clra))) & @as(c_int, 31);
    _ = &r;
    var dr: c_int = (@as(c_int, @bitCast(@as(c_uint, clrb))) & @as(c_int, 31)) - r;
    _ = &dr;
    var g: c_int = (@as(c_int, @bitCast(@as(c_uint, clra))) >> @intCast(5)) & @as(c_int, 31);
    _ = &g;
    var dg: c_int = ((@as(c_int, @bitCast(@as(c_uint, clrb))) >> @intCast(5)) & @as(c_int, 31)) - g;
    _ = &dg;
    var b: c_int = (@as(c_int, @bitCast(@as(c_uint, clra))) >> @intCast(10)) & @as(c_int, 31);
    _ = &b;
    var db: c_int = ((@as(c_int, @bitCast(@as(c_uint, clrb))) >> @intCast(10)) & @as(c_int, 31)) - b;
    _ = &db;
    const SCALE: @"u32" = @as(@"u32", @bitCast(@as(c_int, 1) << @intCast(16)));
    _ = &SCALE;
    r = @as(c_int, @bitCast((@as(@"u32", @bitCast(r)) *% SCALE) +% (SCALE / @as(@"u32", @bitCast(@as(c_int, 2))))));
    dr = @divTrunc(@as(c_int, @bitCast(@as(@"u32", @bitCast(dr)) *% SCALE)), last - first);
    g = @as(c_int, @bitCast((@as(@"u32", @bitCast(g)) *% SCALE) +% (SCALE / @as(@"u32", @bitCast(@as(c_int, 2))))));
    dg = @divTrunc(@as(c_int, @bitCast(@as(@"u32", @bitCast(dg)) *% SCALE)), last - first);
    b = @as(c_int, @bitCast((@as(@"u32", @bitCast(b)) *% SCALE) +% (SCALE / @as(@"u32", @bitCast(@as(c_int, 2))))));
    db = @divTrunc(@as(c_int, @bitCast(@as(@"u32", @bitCast(db)) *% SCALE)), last - first);
    {
        ii = first + @as(c_int, 1);
        while (ii < last) : (ii += 1) {
            r += dr;
            g += dg;
            b += db;
            (blk: {
                const tmp = ii;
                if (tmp >= 0) break :blk pal + @as(usize, @intCast(tmp)) else break :blk pal - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = RGB15(@as(c_int, @bitCast(@as(@"u32", @bitCast(r)) / SCALE)), @as(c_int, @bitCast(@as(@"u32", @bitCast(g)) / SCALE)), @as(c_int, @bitCast(@as(@"u32", @bitCast(b)) / SCALE)));
        }
    }
}
pub export fn pal_gradient_ex(arg_pal: [*c]COLOR, arg_first: c_int, arg_last: c_int, arg_clr_first: COLOR, arg_clr_last: COLOR) void {
    var pal = arg_pal;
    _ = &pal;
    var first = arg_first;
    _ = &first;
    var last = arg_last;
    _ = &last;
    var clr_first = arg_clr_first;
    _ = &clr_first;
    var clr_last = arg_clr_last;
    _ = &clr_last;
    (blk: {
        const tmp = first;
        if (tmp >= 0) break :blk pal + @as(usize, @intCast(tmp)) else break :blk pal - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).* = clr_first;
    (blk: {
        const tmp = last;
        if (tmp >= 0) break :blk pal + @as(usize, @intCast(tmp)) else break :blk pal - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).* = clr_last;
    pal_gradient(pal, first, last);
}
pub extern fn clr_blend_fast(srca: [*c]COLOR, srcb: [*c]COLOR, dst: [*c]COLOR, nclrs: uint, alpha: @"u32") linksection(".iwram") void;
pub extern fn clr_fade_fast(src: [*c]COLOR, clr: COLOR, dst: [*c]COLOR, nclrs: uint, alpha: @"u32") linksection(".iwram") void;
pub fn RGB15(arg_red: c_int, arg_green: c_int, arg_blue: c_int) callconv(.c) COLOR {
    var red = arg_red;
    _ = &red;
    var green = arg_green;
    _ = &green;
    var blue = arg_blue;
    _ = &blue;
    return @as(COLOR, @bitCast(@as(c_short, @truncate((red + (green << @intCast(5))) + (blue << @intCast(10))))));
}
pub fn RGB15_SAFE(arg_red: c_int, arg_green: c_int, arg_blue: c_int) callconv(.c) COLOR {
    var red = arg_red;
    _ = &red;
    var green = arg_green;
    _ = &green;
    var blue = arg_blue;
    _ = &blue;
    return @as(COLOR, @bitCast(@as(c_short, @truncate(((red & @as(c_int, 31)) + ((green & @as(c_int, 31)) << @intCast(5))) + ((blue & @as(c_int, 31)) << @intCast(10))))));
}
pub fn RGB8(arg_red: @"u8", arg_green: @"u8", arg_blue: @"u8") callconv(.c) COLOR {
    var red = arg_red;
    _ = &red;
    var green = arg_green;
    _ = &green;
    var blue = arg_blue;
    _ = &blue;
    return @as(COLOR, @bitCast(@as(c_short, @truncate(((@as(c_int, @bitCast(@as(c_uint, red))) >> @intCast(3)) + ((@as(c_int, @bitCast(@as(c_uint, green))) >> @intCast(3)) << @intCast(5))) + ((@as(c_int, @bitCast(@as(c_uint, blue))) >> @intCast(3)) << @intCast(10))))));
}
pub extern fn bmp8_plot(x: c_int, y: c_int, clr: @"u32", dstBase: ?*anyopaque, dstP: uint) void;
pub extern fn bmp8_hline(x1: c_int, y: c_int, x2: c_int, clr: @"u32", dstBase: ?*anyopaque, dstP: uint) void;
pub extern fn bmp8_vline(x: c_int, y1: c_int, y2: c_int, clr: @"u32", dstBase: ?*anyopaque, dstP: uint) void;
pub extern fn bmp8_line(x1: c_int, y1: c_int, x2: c_int, y2: c_int, clr: @"u32", dstBase: ?*anyopaque, dstP: uint) void;
pub extern fn bmp8_rect(left: c_int, top: c_int, right: c_int, bottom: c_int, clr: @"u32", dstBase: ?*anyopaque, dstP: uint) void;
pub extern fn bmp8_frame(left: c_int, top: c_int, right: c_int, bottom: c_int, clr: @"u32", dstBase: ?*anyopaque, dstP: uint) void;
pub extern fn bmp16_plot(x: c_int, y: c_int, clr: @"u32", dstBase: ?*anyopaque, dstP: uint) void;
pub extern fn bmp16_hline(x1: c_int, y: c_int, x2: c_int, clr: @"u32", dstBase: ?*anyopaque, dstP: uint) void;
pub extern fn bmp16_vline(x: c_int, y1: c_int, y2: c_int, clr: @"u32", dstBase: ?*anyopaque, dstP: uint) void;
pub extern fn bmp16_line(x1: c_int, y1: c_int, x2: c_int, y2: c_int, clr: @"u32", dstBase: ?*anyopaque, dstP: uint) void;
pub extern fn bmp16_rect(left: c_int, top: c_int, right: c_int, bottom: c_int, clr: @"u32", dstBase: ?*anyopaque, dstP: uint) void;
pub extern fn bmp16_frame(left: c_int, top: c_int, right: c_int, bottom: c_int, clr: @"u32", dstBase: ?*anyopaque, dstP: uint) void;
pub fn se_fill(arg_sbb: [*c]SCR_ENTRY, arg_se: SCR_ENTRY) callconv(.c) void {
    var sbb = arg_sbb;
    _ = &sbb;
    var se = arg_se;
    _ = &se;
    memset32(@as(?*anyopaque, @ptrCast(sbb)), dup16(se), @as(uint, @bitCast(@divTrunc(@as(c_int, 2048), @as(c_int, 4)))));
}
pub fn se_plot(arg_sbb: [*c]SCR_ENTRY, arg_x: c_int, arg_y: c_int, arg_se: SCR_ENTRY) callconv(.c) void {
    var sbb = arg_sbb;
    _ = &sbb;
    var x = arg_x;
    _ = &x;
    var y = arg_y;
    _ = &y;
    var se = arg_se;
    _ = &se;
    (blk: {
        const tmp = (y * @as(c_int, 32)) + x;
        if (tmp >= 0) break :blk sbb + @as(usize, @intCast(tmp)) else break :blk sbb - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).* = se;
}
pub fn se_rect(arg_sbb: [*c]SCR_ENTRY, arg_left: c_int, arg_top: c_int, arg_right: c_int, arg_bottom: c_int, arg_se: SCR_ENTRY) callconv(.c) void {
    var sbb = arg_sbb;
    _ = &sbb;
    var left = arg_left;
    _ = &left;
    var top = arg_top;
    _ = &top;
    var right = arg_right;
    _ = &right;
    var bottom = arg_bottom;
    _ = &bottom;
    var se = arg_se;
    _ = &se;
    bmp16_rect(left, top, right, bottom, @as(@"u32", @bitCast(@as(c_uint, se))), @as(?*anyopaque, @ptrCast(sbb)), @as(uint, @bitCast(@as(c_int, 32) * @as(c_int, 2))));
}
pub fn se_frame(arg_sbb: [*c]SCR_ENTRY, arg_left: c_int, arg_top: c_int, arg_right: c_int, arg_bottom: c_int, arg_se: SCR_ENTRY) callconv(.c) void {
    var sbb = arg_sbb;
    _ = &sbb;
    var left = arg_left;
    _ = &left;
    var top = arg_top;
    _ = &top;
    var right = arg_right;
    _ = &right;
    var bottom = arg_bottom;
    _ = &bottom;
    var se = arg_se;
    _ = &se;
    bmp16_frame(left, top, right, bottom, @as(@"u32", @bitCast(@as(c_uint, se))), @as(?*anyopaque, @ptrCast(sbb)), @as(uint, @bitCast(@as(c_int, 32) * @as(c_int, 2))));
}
pub fn se_hline(arg_sbb: [*c]SCR_ENTRY, arg_x0: c_int, arg_x1: c_int, arg_y: c_int, arg_se: SCR_ENTRY) callconv(.c) void {
    var sbb = arg_sbb;
    _ = &sbb;
    var x0 = arg_x0;
    _ = &x0;
    var x1 = arg_x1;
    _ = &x1;
    var y = arg_y;
    _ = &y;
    var se = arg_se;
    _ = &se;
    bmp16_hline(x0, y, x1, @as(@"u32", @bitCast(@as(c_uint, se))), @as(?*anyopaque, @ptrCast(sbb)), @as(uint, @bitCast(@as(c_int, 32) * @as(c_int, 2))));
}
pub fn se_vline(arg_sbb: [*c]SCR_ENTRY, arg_x: c_int, arg_y0: c_int, arg_y1: c_int, arg_se: SCR_ENTRY) callconv(.c) void {
    var sbb = arg_sbb;
    _ = &sbb;
    var x = arg_x;
    _ = &x;
    var y0 = arg_y0;
    _ = &y0;
    var y1 = arg_y1;
    _ = &y1;
    var se = arg_se;
    _ = &se;
    bmp16_vline(x, y0, y1, @as(@"u32", @bitCast(@as(c_uint, se))), @as(?*anyopaque, @ptrCast(sbb)), @as(uint, @bitCast(@as(c_int, 32) * @as(c_int, 2))));
}
pub extern fn se_window(sbb: [*c]SCR_ENTRY, left: c_int, top: c_int, right: c_int, bottom: c_int, se0: SCR_ENTRY) void;
pub fn bg_aff_set(arg_bgaff: [*c]BG_AFFINE, arg_pa: FIXED, arg_pb: FIXED, arg_pc: FIXED, arg_pd: FIXED) callconv(.c) void {
    var bgaff = arg_bgaff;
    _ = &bgaff;
    var pa = arg_pa;
    _ = &pa;
    var pb = arg_pb;
    _ = &pb;
    var pc = arg_pc;
    _ = &pc;
    var pd = arg_pd;
    _ = &pd;
    bgaff.*.pa = @as(s16, @bitCast(@as(c_short, @truncate(pa))));
    bgaff.*.pb = @as(s16, @bitCast(@as(c_short, @truncate(pb))));
    bgaff.*.pc = @as(s16, @bitCast(@as(c_short, @truncate(pc))));
    bgaff.*.pd = @as(s16, @bitCast(@as(c_short, @truncate(pd))));
}
pub fn bg_aff_identity(arg_bgaff: [*c]BG_AFFINE) callconv(.c) void {
    var bgaff = arg_bgaff;
    _ = &bgaff;
    bgaff.*.pa = @as(s16, @bitCast(@as(c_short, @truncate(@as(c_int, 256)))));
    bgaff.*.pb = 0;
    bgaff.*.pc = 0;
    bgaff.*.pd = @as(s16, @bitCast(@as(c_short, @truncate(@as(c_int, 256)))));
}
pub fn bg_aff_scale(arg_bgaff: [*c]BG_AFFINE, arg_sx: FIXED, arg_sy: FIXED) callconv(.c) void {
    var bgaff = arg_bgaff;
    _ = &bgaff;
    var sx = arg_sx;
    _ = &sx;
    var sy = arg_sy;
    _ = &sy;
    bgaff.*.pa = @as(s16, @bitCast(@as(c_short, @truncate(sx))));
    bgaff.*.pb = 0;
    bgaff.*.pb = 0;
    bgaff.*.pd = @as(s16, @bitCast(@as(c_short, @truncate(sy))));
}
pub fn bg_aff_shearx(arg_bgaff: [*c]BG_AFFINE, arg_hx: FIXED) callconv(.c) void {
    var bgaff = arg_bgaff;
    _ = &bgaff;
    var hx = arg_hx;
    _ = &hx;
    bgaff.*.pa = @as(s16, @bitCast(@as(c_short, @truncate(@as(c_int, 256)))));
    bgaff.*.pb = @as(s16, @bitCast(@as(c_short, @truncate(hx))));
    bgaff.*.pc = 0;
    bgaff.*.pd = @as(s16, @bitCast(@as(c_short, @truncate(@as(c_int, 256)))));
}
pub fn bg_aff_sheary(arg_bgaff: [*c]BG_AFFINE, arg_hy: FIXED) callconv(.c) void {
    var bgaff = arg_bgaff;
    _ = &bgaff;
    var hy = arg_hy;
    _ = &hy;
    bgaff.*.pa = @as(s16, @bitCast(@as(c_short, @truncate(@as(c_int, 256)))));
    bgaff.*.pb = 0;
    bgaff.*.pc = @as(s16, @bitCast(@as(c_short, @truncate(hy))));
    bgaff.*.pd = @as(s16, @bitCast(@as(c_short, @truncate(@as(c_int, 256)))));
}
pub extern fn bg_aff_rotate(bgaff: [*c]BG_AFFINE, alpha: @"u16") void;
pub extern fn bg_aff_rotscale(bgaff: [*c]BG_AFFINE, sx: c_int, sy: c_int, alpha: @"u16") void;
pub extern fn bg_aff_premul(dst: [*c]BG_AFFINE, src: [*c]const BG_AFFINE) void;
pub extern fn bg_aff_postmul(dst: [*c]BG_AFFINE, src: [*c]const BG_AFFINE) void;
pub extern fn bg_aff_rotscale2(bgaff: [*c]BG_AFFINE, as: [*c]const AFF_SRC) void;
pub extern fn bg_rotscale_ex(bgaff: [*c]BG_AFFINE, asx: [*c]const AFF_SRC_EX) void;
pub fn m3_fill(arg_clr: COLOR) callconv(.c) void {
    var clr = arg_clr;
    _ = &clr;
    memset32(@as(?*anyopaque, @ptrCast(@as([*c]COLOR, @ptrFromInt(@as(c_int, 100663296))))), dup16(clr), @as(uint, @bitCast(@divTrunc(@as(c_int, 76800), @as(c_int, 4)))));
}
pub fn m3_plot(arg_x: c_int, arg_y: c_int, arg_clr: COLOR) callconv(.c) void {
    var x = arg_x;
    _ = &x;
    var y = arg_y;
    _ = &y;
    var clr = arg_clr;
    _ = &clr;
    (blk: {
        const tmp = (y * @as(c_int, 240)) + x;
        if (tmp >= 0) break :blk @as([*c]COLOR, @ptrFromInt(@as(c_int, 100663296))) + @as(usize, @intCast(tmp)) else break :blk @as([*c]COLOR, @ptrFromInt(@as(c_int, 100663296))) - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).* = clr;
}
pub fn m3_hline(arg_x1: c_int, arg_y: c_int, arg_x2: c_int, arg_clr: COLOR) callconv(.c) void {
    var x1 = arg_x1;
    _ = &x1;
    var y = arg_y;
    _ = &y;
    var x2 = arg_x2;
    _ = &x2;
    var clr = arg_clr;
    _ = &clr;
    bmp16_hline(x1, y, x2, @as(@"u32", @bitCast(@as(c_uint, clr))), @as(?*anyopaque, @ptrCast(@as([*c]COLOR, @ptrFromInt(@as(c_int, 100663296))))), @as(uint, @bitCast(@as(c_int, 240) * @as(c_int, 2))));
}
pub fn m3_vline(arg_x: c_int, arg_y1: c_int, arg_y2: c_int, arg_clr: COLOR) callconv(.c) void {
    var x = arg_x;
    _ = &x;
    var y1 = arg_y1;
    _ = &y1;
    var y2 = arg_y2;
    _ = &y2;
    var clr = arg_clr;
    _ = &clr;
    bmp16_vline(x, y1, y2, @as(@"u32", @bitCast(@as(c_uint, clr))), @as(?*anyopaque, @ptrCast(@as([*c]COLOR, @ptrFromInt(@as(c_int, 100663296))))), @as(uint, @bitCast(@as(c_int, 240) * @as(c_int, 2))));
}
pub fn m3_line(arg_x1: c_int, arg_y1: c_int, arg_x2: c_int, arg_y2: c_int, arg_clr: COLOR) callconv(.c) void {
    var x1 = arg_x1;
    _ = &x1;
    var y1 = arg_y1;
    _ = &y1;
    var x2 = arg_x2;
    _ = &x2;
    var y2 = arg_y2;
    _ = &y2;
    var clr = arg_clr;
    _ = &clr;
    bmp16_line(x1, y1, x2, y2, @as(@"u32", @bitCast(@as(c_uint, clr))), @as(?*anyopaque, @ptrCast(@as([*c]COLOR, @ptrFromInt(@as(c_int, 100663296))))), @as(uint, @bitCast(@as(c_int, 240) * @as(c_int, 2))));
}
pub fn m3_rect(arg_left: c_int, arg_top: c_int, arg_right: c_int, arg_bottom: c_int, arg_clr: COLOR) callconv(.c) void {
    var left = arg_left;
    _ = &left;
    var top = arg_top;
    _ = &top;
    var right = arg_right;
    _ = &right;
    var bottom = arg_bottom;
    _ = &bottom;
    var clr = arg_clr;
    _ = &clr;
    bmp16_rect(left, top, right, bottom, @as(@"u32", @bitCast(@as(c_uint, clr))), @as(?*anyopaque, @ptrCast(@as([*c]COLOR, @ptrFromInt(@as(c_int, 100663296))))), @as(uint, @bitCast(@as(c_int, 240) * @as(c_int, 2))));
}
pub fn m3_frame(arg_left: c_int, arg_top: c_int, arg_right: c_int, arg_bottom: c_int, arg_clr: COLOR) callconv(.c) void {
    var left = arg_left;
    _ = &left;
    var top = arg_top;
    _ = &top;
    var right = arg_right;
    _ = &right;
    var bottom = arg_bottom;
    _ = &bottom;
    var clr = arg_clr;
    _ = &clr;
    bmp16_frame(left, top, right, bottom, @as(@"u32", @bitCast(@as(c_uint, clr))), @as(?*anyopaque, @ptrCast(@as([*c]COLOR, @ptrFromInt(@as(c_int, 100663296))))), @as(uint, @bitCast(@as(c_int, 240) * @as(c_int, 2))));
}
pub fn m4_fill(arg_clrid: @"u8") callconv(.c) void {
    var clrid = arg_clrid;
    _ = &clrid;
    memset32(@as(?*anyopaque, @ptrCast(vid_page)), quad8(clrid), @as(uint, @bitCast(@divTrunc(@as(c_int, 38400), @as(c_int, 4)))));
}
pub fn m4_plot(arg_x: c_int, arg_y: c_int, arg_clrid: @"u8") callconv(.c) void {
    var x = arg_x;
    _ = &x;
    var y = arg_y;
    _ = &y;
    var clrid = arg_clrid;
    _ = &clrid;
    var dst: [*c]@"u16" = &(blk: {
        const tmp = ((y * @as(c_int, 240)) + x) >> @intCast(1);
        if (tmp >= 0) break :blk vid_page + @as(usize, @intCast(tmp)) else break :blk vid_page - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    _ = &dst;
    if ((x & @as(c_int, 1)) != 0) {
        dst.* = @as(@"u16", @bitCast(@as(c_short, @truncate((@as(c_int, @bitCast(@as(c_uint, dst.*))) & @as(c_int, 255)) | (@as(c_int, @bitCast(@as(c_uint, clrid))) << @intCast(8))))));
    } else {
        dst.* = @as(@"u16", @bitCast(@as(c_short, @truncate((@as(c_int, @bitCast(@as(c_uint, dst.*))) & ~@as(c_int, 255)) | @as(c_int, @bitCast(@as(c_uint, clrid)))))));
    }
}
pub fn m4_hline(arg_x1: c_int, arg_y: c_int, arg_x2: c_int, arg_clrid: @"u8") callconv(.c) void {
    var x1 = arg_x1;
    _ = &x1;
    var y = arg_y;
    _ = &y;
    var x2 = arg_x2;
    _ = &x2;
    var clrid = arg_clrid;
    _ = &clrid;
    bmp8_hline(x1, y, x2, @as(@"u32", @bitCast(@as(c_uint, clrid))), @as(?*anyopaque, @ptrCast(vid_page)), @as(uint, @bitCast(@as(c_int, 240))));
}
pub fn m4_vline(arg_x: c_int, arg_y1: c_int, arg_y2: c_int, arg_clrid: @"u8") callconv(.c) void {
    var x = arg_x;
    _ = &x;
    var y1 = arg_y1;
    _ = &y1;
    var y2 = arg_y2;
    _ = &y2;
    var clrid = arg_clrid;
    _ = &clrid;
    bmp8_vline(x, y1, y2, @as(@"u32", @bitCast(@as(c_uint, clrid))), @as(?*anyopaque, @ptrCast(vid_page)), @as(uint, @bitCast(@as(c_int, 240))));
}
pub fn m4_line(arg_x1: c_int, arg_y1: c_int, arg_x2: c_int, arg_y2: c_int, arg_clrid: @"u8") callconv(.c) void {
    var x1 = arg_x1;
    _ = &x1;
    var y1 = arg_y1;
    _ = &y1;
    var x2 = arg_x2;
    _ = &x2;
    var y2 = arg_y2;
    _ = &y2;
    var clrid = arg_clrid;
    _ = &clrid;
    bmp8_line(x1, y1, x2, y2, @as(@"u32", @bitCast(@as(c_uint, clrid))), @as(?*anyopaque, @ptrCast(vid_page)), @as(uint, @bitCast(@as(c_int, 240))));
}
pub fn m4_rect(arg_left: c_int, arg_top: c_int, arg_right: c_int, arg_bottom: c_int, arg_clrid: @"u8") callconv(.c) void {
    var left = arg_left;
    _ = &left;
    var top = arg_top;
    _ = &top;
    var right = arg_right;
    _ = &right;
    var bottom = arg_bottom;
    _ = &bottom;
    var clrid = arg_clrid;
    _ = &clrid;
    bmp8_rect(left, top, right, bottom, @as(@"u32", @bitCast(@as(c_uint, clrid))), @as(?*anyopaque, @ptrCast(vid_page)), @as(uint, @bitCast(@as(c_int, 240))));
}
pub fn m4_frame(arg_left: c_int, arg_top: c_int, arg_right: c_int, arg_bottom: c_int, arg_clrid: @"u8") callconv(.c) void {
    var left = arg_left;
    _ = &left;
    var top = arg_top;
    _ = &top;
    var right = arg_right;
    _ = &right;
    var bottom = arg_bottom;
    _ = &bottom;
    var clrid = arg_clrid;
    _ = &clrid;
    bmp8_frame(left, top, right, bottom, @as(@"u32", @bitCast(@as(c_uint, clrid))), @as(?*anyopaque, @ptrCast(vid_page)), @as(uint, @bitCast(@as(c_int, 240))));
}
pub fn m5_fill(arg_clr: COLOR) callconv(.c) void {
    var clr = arg_clr;
    _ = &clr;
    memset32(@as(?*anyopaque, @ptrCast(vid_page)), dup16(clr), @as(uint, @bitCast(@divTrunc(@as(c_int, 40960), @as(c_int, 4)))));
}
pub fn m5_plot(arg_x: c_int, arg_y: c_int, arg_clr: COLOR) callconv(.c) void {
    var x = arg_x;
    _ = &x;
    var y = arg_y;
    _ = &y;
    var clr = arg_clr;
    _ = &clr;
    (blk: {
        const tmp = (y * @as(c_int, 160)) + x;
        if (tmp >= 0) break :blk vid_page + @as(usize, @intCast(tmp)) else break :blk vid_page - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).* = clr;
}
pub fn m5_hline(arg_x1: c_int, arg_y: c_int, arg_x2: c_int, arg_clr: COLOR) callconv(.c) void {
    var x1 = arg_x1;
    _ = &x1;
    var y = arg_y;
    _ = &y;
    var x2 = arg_x2;
    _ = &x2;
    var clr = arg_clr;
    _ = &clr;
    bmp16_hline(x1, y, x2, @as(@"u32", @bitCast(@as(c_uint, clr))), @as(?*anyopaque, @ptrCast(vid_page)), @as(uint, @bitCast(@as(c_int, 160) * @as(c_int, 2))));
}
pub fn m5_vline(arg_x: c_int, arg_y1: c_int, arg_y2: c_int, arg_clr: COLOR) callconv(.c) void {
    var x = arg_x;
    _ = &x;
    var y1 = arg_y1;
    _ = &y1;
    var y2 = arg_y2;
    _ = &y2;
    var clr = arg_clr;
    _ = &clr;
    bmp16_vline(x, y1, y2, @as(@"u32", @bitCast(@as(c_uint, clr))), @as(?*anyopaque, @ptrCast(vid_page)), @as(uint, @bitCast(@as(c_int, 160) * @as(c_int, 2))));
}
pub fn m5_line(arg_x1: c_int, arg_y1: c_int, arg_x2: c_int, arg_y2: c_int, arg_clr: COLOR) callconv(.c) void {
    var x1 = arg_x1;
    _ = &x1;
    var y1 = arg_y1;
    _ = &y1;
    var x2 = arg_x2;
    _ = &x2;
    var y2 = arg_y2;
    _ = &y2;
    var clr = arg_clr;
    _ = &clr;
    bmp16_line(x1, y1, x2, y2, @as(@"u32", @bitCast(@as(c_uint, clr))), @as(?*anyopaque, @ptrCast(vid_page)), @as(uint, @bitCast(@as(c_int, 160) * @as(c_int, 2))));
}
pub fn m5_rect(arg_left: c_int, arg_top: c_int, arg_right: c_int, arg_bottom: c_int, arg_clr: COLOR) callconv(.c) void {
    var left = arg_left;
    _ = &left;
    var top = arg_top;
    _ = &top;
    var right = arg_right;
    _ = &right;
    var bottom = arg_bottom;
    _ = &bottom;
    var clr = arg_clr;
    _ = &clr;
    bmp16_rect(left, top, right, bottom, @as(@"u32", @bitCast(@as(c_uint, clr))), @as(?*anyopaque, @ptrCast(vid_page)), @as(uint, @bitCast(@as(c_int, 160) * @as(c_int, 2))));
}
pub fn m5_frame(arg_left: c_int, arg_top: c_int, arg_right: c_int, arg_bottom: c_int, arg_clr: COLOR) callconv(.c) void {
    var left = arg_left;
    _ = &left;
    var top = arg_top;
    _ = &top;
    var right = arg_right;
    _ = &right;
    var bottom = arg_bottom;
    _ = &bottom;
    var clr = arg_clr;
    _ = &clr;
    bmp16_frame(left, top, right, bottom, @as(@"u32", @bitCast(@as(c_uint, clr))), @as(?*anyopaque, @ptrCast(vid_page)), @as(uint, @bitCast(@as(c_int, 160) * @as(c_int, 2))));
}
pub fn bg_aff_copy(arg_dst: [*c]BG_AFFINE, arg_src: [*c]const BG_AFFINE) callconv(.c) void {
    var dst = arg_dst;
    _ = &dst;
    var src = arg_src;
    _ = &src;
    dst.* = src.*;
}
pub const struct_BUP = extern struct {
    src_len: @"u16" = @import("std").mem.zeroes(@"u16"),
    src_bpp: @"u8" = @import("std").mem.zeroes(@"u8"),
    dst_bpp: @"u8" = @import("std").mem.zeroes(@"u8"),
    dst_ofs: @"u32" = @import("std").mem.zeroes(@"u32"),
};
pub const BUP = struct_BUP;
pub const MultiBootParam = extern struct {
    reserved1: [5]@"u32" = @import("std").mem.zeroes([5]@"u32"),
    handshake_data: @"u8" = @import("std").mem.zeroes(@"u8"),
    padding: @"u8" = @import("std").mem.zeroes(@"u8"),
    handshake_timeout: @"u16" = @import("std").mem.zeroes(@"u16"),
    probe_count: @"u8" = @import("std").mem.zeroes(@"u8"),
    client_data: [3]@"u8" = @import("std").mem.zeroes([3]@"u8"),
    palette_data: @"u8" = @import("std").mem.zeroes(@"u8"),
    response_bit: @"u8" = @import("std").mem.zeroes(@"u8"),
    client_bit: @"u8" = @import("std").mem.zeroes(@"u8"),
    reserved2: @"u8" = @import("std").mem.zeroes(@"u8"),
    boot_srcp: [*c]@"u8" = @import("std").mem.zeroes([*c]@"u8"),
    boot_endp: [*c]@"u8" = @import("std").mem.zeroes([*c]@"u8"),
    masterp: [*c]@"u8" = @import("std").mem.zeroes([*c]@"u8"),
    reserved3: [3][*c]@"u8" = @import("std").mem.zeroes([3][*c]@"u8"),
    system_work2: [4]@"u32" = @import("std").mem.zeroes([4]@"u32"),
    sendflag: @"u8" = @import("std").mem.zeroes(@"u8"),
    probe_target_bit: @"u8" = @import("std").mem.zeroes(@"u8"),
    check_wait: @"u8" = @import("std").mem.zeroes(@"u8"),
    server_type: @"u8" = @import("std").mem.zeroes(@"u8"),
};
pub extern fn SoftReset() void;
pub extern fn RegisterRamReset(flags: @"u32") void;
pub extern fn Halt() void;
pub extern fn Stop() void;
pub extern fn IntrWait(flagClear: @"u32", irq: @"u32") void;
pub extern fn VBlankIntrWait() void;
pub extern fn Div(num: s32, den: s32) s32;
pub extern fn DivArm(den: s32, num: s32) s32;
pub extern fn Sqrt(num: @"u32") @"u32";
pub extern fn ArcTan(dydx: s16) s16;
pub extern fn ArcTan2(x: s16, y: s16) s16;
pub extern fn CpuSet(src: ?*const anyopaque, dst: ?*anyopaque, mode: @"u32") void;
pub extern fn CpuFastSet(src: ?*const anyopaque, dst: ?*anyopaque, mode: @"u32") void;
pub extern fn BiosCheckSum() @"u32";
pub extern fn ObjAffineSet(src: [*c]const ObjAffineSource, dst: ?*anyopaque, num: s32, offset: s32) void;
pub extern fn BgAffineSet(src: [*c]const BgAffineSource, dst: [*c]BgAffineDest, num: s32) void;
pub extern fn BitUnPack(src: ?*const anyopaque, dst: ?*anyopaque, bup: [*c]const BUP) void;
pub extern fn LZ77UnCompWram(src: ?*const anyopaque, dst: ?*anyopaque) void;
pub extern fn LZ77UnCompVram(src: ?*const anyopaque, dst: ?*anyopaque) void;
pub extern fn HuffUnComp(src: ?*const anyopaque, dst: ?*anyopaque) void;
pub extern fn RLUnCompWram(src: ?*const anyopaque, dst: ?*anyopaque) void;
pub extern fn RLUnCompVram(src: ?*const anyopaque, dst: ?*anyopaque) void;
pub extern fn Diff8bitUnFilterWram(src: ?*const anyopaque, dst: ?*anyopaque) void;
pub extern fn Diff8bitUnFilterVram(src: ?*const anyopaque, dst: ?*anyopaque) void;
pub extern fn Diff16bitUnFilter(src: ?*const anyopaque, dst: ?*anyopaque) void;
pub extern fn SoundBias(bias: @"u32") void;
pub extern fn SoundDriverInit(src: ?*anyopaque) void;
pub extern fn SoundDriverMode(mode: @"u32") void;
pub extern fn SoundDriverMain() void;
pub extern fn SoundDriverVSync() void;
pub extern fn SoundChannelClear() void;
pub extern fn MidiKey2Freq(wa: ?*anyopaque, mk: @"u8", fp: @"u8") @"u32";
pub extern fn SoundDriverVSyncOff() void;
pub extern fn SoundDriverVSyncOn() void;
pub extern fn MultiBoot(mb: [*c]MultiBootParam, mode: @"u32") c_int;
pub extern fn VBlankIntrDelay(count: @"u32") void;
pub extern fn DivSafe(num: c_int, den: c_int) c_int;
pub extern fn Mod(num: c_int, den: c_int) c_int;
pub extern fn DivAbs(num: c_int, den: c_int) @"u32";
pub extern fn DivArmMod(den: c_int, num: c_int) c_int;
pub extern fn DivArmAbs(den: c_int, num: c_int) @"u32";
pub extern fn CpuFastFill(wd: @"u32", dst: ?*anyopaque, count: @"u32") void;
pub fn sgn(arg_x: c_int) callconv(.c) c_int {
    var x = arg_x;
    _ = &x;
    return if (x >= @as(c_int, 0)) @as(c_int, 1) else -@as(c_int, 1);
}
pub fn sgn3(arg_x: c_int) callconv(.c) c_int {
    var x = arg_x;
    _ = &x;
    return (x >> @intCast(31)) - (-x >> @intCast(31));
}
pub fn max(arg_a: c_int, arg_b: c_int) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    return if (a > b) a else b;
}
pub fn min(arg_a: c_int, arg_b: c_int) callconv(.c) c_int {
    var a = arg_a;
    _ = &a;
    var b = arg_b;
    _ = &b;
    return if (a < b) a else b;
}
pub fn in_range(arg_x: c_int, arg_min_1: c_int, arg_max_2: c_int) callconv(.c) BOOL {
    var x = arg_x;
    _ = &x;
    var min_1 = arg_min_1;
    _ = &min_1;
    var max_2 = arg_max_2;
    _ = &max_2;
    return @as(BOOL, @intFromBool(@as(@"u32", @bitCast(x - min_1)) < @as(@"u32", @bitCast(max_2 - min_1))));
}
pub fn clamp(arg_x: c_int, arg_min_1: c_int, arg_max_2: c_int) callconv(.c) c_int {
    var x = arg_x;
    _ = &x;
    var min_1 = arg_min_1;
    _ = &min_1;
    var max_2 = arg_max_2;
    _ = &max_2;
    return if (x >= max_2) max_2 - @as(c_int, 1) else if (x < min_1) min_1 else x;
}
pub fn reflect(arg_x: c_int, arg_min_1: c_int, arg_max_2: c_int) callconv(.c) c_int {
    var x = arg_x;
    _ = &x;
    var min_1 = arg_min_1;
    _ = &min_1;
    var max_2 = arg_max_2;
    _ = &max_2;
    return if (x >= max_2) (@as(c_int, 2) * (max_2 - @as(c_int, 1))) - x else if (x < min_1) (@as(c_int, 2) * min_1) - x else x;
}
pub fn wrap(arg_x: c_int, arg_min_1: c_int, arg_max_2: c_int) callconv(.c) c_int {
    var x = arg_x;
    _ = &x;
    var min_1 = arg_min_1;
    _ = &min_1;
    var max_2 = arg_max_2;
    _ = &max_2;
    return if (x >= max_2) (x + min_1) - max_2 else if (x < min_1) (x + max_2) - min_1 else x;
}
pub fn int2fx(arg_d: c_int) callconv(.c) FIXED {
    var d = arg_d;
    _ = &d;
    return d << @intCast(8);
}
pub fn float2fx(arg_f: f32) callconv(.c) FIXED {
    var f = arg_f;
    _ = &f;
    return @as(FIXED, @intFromFloat(f * @as(f32, @floatFromInt(@as(c_int, 1) << @intCast(8)))));
}
pub fn fx2uint(arg_fx: FIXED) callconv(.c) @"u32" {
    var fx = arg_fx;
    _ = &fx;
    return @as(@"u32", @bitCast(fx >> @intCast(8)));
}
pub fn fx2ufrac(arg_fx: FIXED) callconv(.c) @"u32" {
    var fx = arg_fx;
    _ = &fx;
    return @as(@"u32", @bitCast(fx & ((@as(c_int, 1) << @intCast(8)) - @as(c_int, 1))));
}
pub fn fx2int(arg_fx: FIXED) callconv(.c) c_int {
    var fx = arg_fx;
    _ = &fx;
    return @divTrunc(fx, @as(c_int, 1) << @intCast(8));
}
pub fn fx2float(arg_fx: FIXED) callconv(.c) f32 {
    var fx = arg_fx;
    _ = &fx;
    return @as(f32, @floatFromInt(fx)) / @as(f32, @floatFromInt(@as(c_int, 1) << @intCast(8)));
}
pub fn fxadd(arg_fa: FIXED, arg_fb: FIXED) callconv(.c) FIXED {
    var fa = arg_fa;
    _ = &fa;
    var fb = arg_fb;
    _ = &fb;
    return fa + fb;
}
pub fn fxsub(arg_fa: FIXED, arg_fb: FIXED) callconv(.c) FIXED {
    var fa = arg_fa;
    _ = &fa;
    var fb = arg_fb;
    _ = &fb;
    return fa - fb;
}
pub fn fxmul(arg_fa: FIXED, arg_fb: FIXED) callconv(.c) FIXED {
    var fa = arg_fa;
    _ = &fa;
    var fb = arg_fb;
    _ = &fb;
    return (fa * fb) >> @intCast(8);
}
pub fn fxdiv(arg_fa: FIXED, arg_fb: FIXED) callconv(.c) FIXED {
    var fa = arg_fa;
    _ = &fa;
    var fb = arg_fb;
    _ = &fb;
    return @divTrunc(fa * (@as(c_int, 1) << @intCast(8)), fb);
}
pub fn fxmul64(arg_fa: FIXED, arg_fb: FIXED) callconv(.c) FIXED {
    var fa = arg_fa;
    _ = &fa;
    var fb = arg_fb;
    _ = &fb;
    return @as(FIXED, @bitCast(@as(c_int, @truncate((@as(s64, @bitCast(@as(c_longlong, fa))) * @as(s64, @bitCast(@as(c_longlong, fb)))) >> @intCast(8)))));
}
pub fn fxdiv64(arg_fa: FIXED, arg_fb: FIXED) callconv(.c) FIXED {
    var fa = arg_fa;
    _ = &fa;
    var fb = arg_fb;
    _ = &fb;
    return @as(FIXED, @bitCast(@as(c_int, @truncate(@divTrunc(@as(s64, @bitCast(@as(c_longlong, fa))) << @intCast(8), @as(s64, @bitCast(@as(c_longlong, fb))))))));
}
pub extern var div_lut: [257]s32;
pub extern var sin_lut: [514]s16;
pub fn lu_sin(arg_theta: uint) callconv(.c) s32 {
    var theta = arg_theta;
    _ = &theta;
    return @as(s32, @bitCast(@as(c_int, sin_lut[(theta >> @intCast(7)) & @as(uint, @bitCast(@as(c_int, 511)))])));
}
pub fn lu_cos(arg_theta: uint) callconv(.c) s32 {
    var theta = arg_theta;
    _ = &theta;
    return @as(s32, @bitCast(@as(c_int, sin_lut[((theta >> @intCast(7)) +% @as(uint, @bitCast(@as(c_int, 128)))) & @as(uint, @bitCast(@as(c_int, 511)))])));
}
pub fn lu_div(arg_x: uint) callconv(.c) uint {
    var x = arg_x;
    _ = &x;
    return @as(uint, @bitCast(div_lut[x]));
}
pub fn lu_lerp32(lut: [*c]const s32, arg_x: uint, shift: uint) callconv(.c) c_int {
    _ = &lut;
    var x = arg_x;
    _ = &x;
    _ = &shift;
    var xa: c_int = undefined;
    _ = &xa;
    var ya: c_int = undefined;
    _ = &ya;
    var yb: c_int = undefined;
    _ = &yb;
    xa = @as(c_int, @bitCast(x >> @intCast(shift)));
    ya = (blk: {
        const tmp = xa;
        if (tmp >= 0) break :blk lut + @as(usize, @intCast(tmp)) else break :blk lut - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    yb = (blk: {
        const tmp = xa + @as(c_int, 1);
        if (tmp >= 0) break :blk lut + @as(usize, @intCast(tmp)) else break :blk lut - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    return @as(c_int, @bitCast(@as(uint, @bitCast(ya)) +% ((@as(uint, @bitCast(yb - ya)) *% (x -% @as(uint, @bitCast(xa << @intCast(shift))))) >> @intCast(shift))));
}
pub fn lu_lerp16(lut: [*c]const s16, arg_x: uint, shift: uint) callconv(.c) c_int {
    _ = &lut;
    var x = arg_x;
    _ = &x;
    _ = &shift;
    var xa: c_int = undefined;
    _ = &xa;
    var ya: c_int = undefined;
    _ = &ya;
    var yb: c_int = undefined;
    _ = &yb;
    xa = @as(c_int, @bitCast(x >> @intCast(shift)));
    ya = @as(c_int, @bitCast(@as(c_int, (blk: {
        const tmp = xa;
        if (tmp >= 0) break :blk lut + @as(usize, @intCast(tmp)) else break :blk lut - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*)));
    yb = @as(c_int, @bitCast(@as(c_int, (blk: {
        const tmp = xa + @as(c_int, 1);
        if (tmp >= 0) break :blk lut + @as(usize, @intCast(tmp)) else break :blk lut - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*)));
    return @as(c_int, @bitCast(@as(uint, @bitCast(ya)) +% ((@as(uint, @bitCast(yb - ya)) *% (x -% @as(uint, @bitCast(xa << @intCast(shift))))) >> @intCast(shift))));
}
pub const struct_RECT = extern struct {
    left: c_int = @import("std").mem.zeroes(c_int),
    top: c_int = @import("std").mem.zeroes(c_int),
    right: c_int = @import("std").mem.zeroes(c_int),
    bottom: c_int = @import("std").mem.zeroes(c_int),
};
pub const struct_POINT = extern struct {
    x: c_int = @import("std").mem.zeroes(c_int),
    y: c_int = @import("std").mem.zeroes(c_int),
};
pub const POINT = struct_POINT;
pub const POINT32 = struct_POINT;
pub fn pt_set(arg_pd: [*c]POINT, arg_x: c_int, arg_y: c_int) callconv(.c) [*c]POINT {
    var pd = arg_pd;
    _ = &pd;
    var x = arg_x;
    _ = &x;
    var y = arg_y;
    _ = &y;
    pd.*.x = x;
    pd.*.y = y;
    return pd;
}
pub fn pt_add(arg_pd: [*c]POINT, arg_pa: [*c]const POINT, arg_pb: [*c]const POINT) callconv(.c) [*c]POINT {
    var pd = arg_pd;
    _ = &pd;
    var pa = arg_pa;
    _ = &pa;
    var pb = arg_pb;
    _ = &pb;
    pd.*.x = pa.*.x + pb.*.x;
    pd.*.y = pa.*.x + pb.*.y;
    return pd;
}
pub fn pt_sub(arg_pd: [*c]POINT, arg_pa: [*c]const POINT, arg_pb: [*c]const POINT) callconv(.c) [*c]POINT {
    var pd = arg_pd;
    _ = &pd;
    var pa = arg_pa;
    _ = &pa;
    var pb = arg_pb;
    _ = &pb;
    pd.*.x = pa.*.x - pb.*.x;
    pd.*.y = pa.*.x - pb.*.y;
    return pd;
}
pub fn pt_scale(arg_pd: [*c]POINT, arg_pa: [*c]const POINT, arg_c: c_int) callconv(.c) [*c]POINT {
    var pd = arg_pd;
    _ = &pd;
    var pa = arg_pa;
    _ = &pa;
    var c = arg_c;
    _ = &c;
    pd.*.x = pa.*.x * c;
    pd.*.y = pa.*.y * c;
    return pd;
}
pub fn pt_add_eq(arg_pd: [*c]POINT, arg_pb: [*c]const POINT) callconv(.c) [*c]POINT {
    var pd = arg_pd;
    _ = &pd;
    var pb = arg_pb;
    _ = &pb;
    pd.*.x += pb.*.y;
    pd.*.y += pb.*.y;
    return pd;
}
pub fn pt_sub_eq(arg_pd: [*c]POINT, arg_pb: [*c]const POINT) callconv(.c) [*c]POINT {
    var pd = arg_pd;
    _ = &pd;
    var pb = arg_pb;
    _ = &pb;
    pd.*.x -= pb.*.y;
    pd.*.y -= pb.*.y;
    return pd;
}
pub fn pt_scale_eq(arg_pd: [*c]POINT, arg_c: c_int) callconv(.c) [*c]POINT {
    var pd = arg_pd;
    _ = &pd;
    var c = arg_c;
    _ = &c;
    pd.*.x *= c;
    pd.*.y *= c;
    return pd;
}
pub fn pt_cross(arg_pa: [*c]const POINT, arg_pb: [*c]const POINT) callconv(.c) c_int {
    var pa = arg_pa;
    _ = &pa;
    var pb = arg_pb;
    _ = &pb;
    return (pa.*.x * pb.*.y) - (pa.*.y * pb.*.x);
}
pub fn pt_dot(arg_pa: [*c]const POINT, arg_pb: [*c]const POINT) callconv(.c) c_int {
    var pa = arg_pa;
    _ = &pa;
    var pb = arg_pb;
    _ = &pb;
    return (pa.*.x * pb.*.x) + (pa.*.y * pb.*.y);
}
pub extern fn pt_in_rect(pt: [*c]const POINT, rc: [*c]const struct_RECT) c_int;
pub const RECT = struct_RECT;
pub const RECT32 = struct_RECT;
pub fn rc_set(arg_rc: [*c]RECT, arg_l: c_int, arg_t: c_int, arg_r: c_int, arg_b: c_int) callconv(.c) [*c]RECT {
    var rc = arg_rc;
    _ = &rc;
    var l = arg_l;
    _ = &l;
    var t = arg_t;
    _ = &t;
    var r = arg_r;
    _ = &r;
    var b = arg_b;
    _ = &b;
    rc.*.left = l;
    rc.*.top = t;
    rc.*.right = r;
    rc.*.bottom = b;
    return rc;
}
pub fn rc_set2(arg_rc: [*c]RECT, arg_x: c_int, arg_y: c_int, arg_w: c_int, arg_h: c_int) callconv(.c) [*c]RECT {
    var rc = arg_rc;
    _ = &rc;
    var x = arg_x;
    _ = &x;
    var y = arg_y;
    _ = &y;
    var w = arg_w;
    _ = &w;
    var h = arg_h;
    _ = &h;
    rc.*.left = x;
    rc.*.top = y;
    rc.*.right = x + w;
    rc.*.bottom = y + h;
    return rc;
}
pub fn rc_width(arg_rc: [*c]const RECT) callconv(.c) c_int {
    var rc = arg_rc;
    _ = &rc;
    return rc.*.right - rc.*.left;
}
pub fn rc_height(arg_rc: [*c]const RECT) callconv(.c) c_int {
    var rc = arg_rc;
    _ = &rc;
    return rc.*.bottom - rc.*.top;
}
pub fn rc_set_pos(arg_rc: [*c]RECT, arg_x: c_int, arg_y: c_int) callconv(.c) [*c]RECT {
    var rc = arg_rc;
    _ = &rc;
    var x = arg_x;
    _ = &x;
    var y = arg_y;
    _ = &y;
    rc.*.right += x - rc.*.left;
    rc.*.left = x;
    rc.*.bottom += y - rc.*.top;
    rc.*.top = y;
    return rc;
}
pub fn rc_set_size(arg_rc: [*c]RECT, arg_w: c_int, arg_h: c_int) callconv(.c) [*c]RECT {
    var rc = arg_rc;
    _ = &rc;
    var w = arg_w;
    _ = &w;
    var h = arg_h;
    _ = &h;
    rc.*.right = rc.*.left + w;
    rc.*.bottom = rc.*.top + h;
    return rc;
}
pub fn rc_move(arg_rc: [*c]RECT, arg_dx: c_int, arg_dy: c_int) callconv(.c) [*c]RECT {
    var rc = arg_rc;
    _ = &rc;
    var dx = arg_dx;
    _ = &dx;
    var dy = arg_dy;
    _ = &dy;
    rc.*.left += dx;
    rc.*.top += dy;
    rc.*.right += dx;
    rc.*.bottom += dy;
    return rc;
}
pub fn rc_inflate(arg_rc: [*c]RECT, arg_dw: c_int, arg_dh: c_int) callconv(.c) [*c]RECT {
    var rc = arg_rc;
    _ = &rc;
    var dw = arg_dw;
    _ = &dw;
    var dh = arg_dh;
    _ = &dh;
    rc.*.left -= dw;
    rc.*.top -= dh;
    rc.*.right += dw;
    rc.*.bottom += dh;
    return rc;
}
pub fn rc_inflate2(arg_rc: [*c]RECT, arg_dr: [*c]const RECT) callconv(.c) [*c]RECT {
    var rc = arg_rc;
    _ = &rc;
    var dr = arg_dr;
    _ = &dr;
    rc.*.left += dr.*.left;
    rc.*.top += dr.*.top;
    rc.*.right += dr.*.right;
    rc.*.bottom += dr.*.bottom;
    return rc;
}
pub extern fn rc_normalize(rc: [*c]RECT) [*c]RECT;
pub const struct_VECTOR = extern struct {
    x: FIXED = @import("std").mem.zeroes(FIXED),
    y: FIXED = @import("std").mem.zeroes(FIXED),
    z: FIXED = @import("std").mem.zeroes(FIXED),
};
pub const VECTOR = struct_VECTOR;
pub fn vec_set(arg_vd: [*c]VECTOR, arg_x: FIXED, arg_y: FIXED, arg_z: FIXED) callconv(.c) [*c]VECTOR {
    var vd = arg_vd;
    _ = &vd;
    var x = arg_x;
    _ = &x;
    var y = arg_y;
    _ = &y;
    var z = arg_z;
    _ = &z;
    vd.*.x = x;
    vd.*.y = y;
    vd.*.z = z;
    return vd;
}
pub fn vec_add(arg_vd: [*c]VECTOR, arg_va: [*c]const VECTOR, arg_vb: [*c]const VECTOR) callconv(.c) [*c]VECTOR {
    var vd = arg_vd;
    _ = &vd;
    var va = arg_va;
    _ = &va;
    var vb = arg_vb;
    _ = &vb;
    vd.*.x = va.*.x + vb.*.x;
    vd.*.y = va.*.y + vb.*.y;
    vd.*.z = va.*.z + vb.*.z;
    return vd;
}
pub fn vec_sub(arg_vd: [*c]VECTOR, arg_va: [*c]const VECTOR, arg_vb: [*c]const VECTOR) callconv(.c) [*c]VECTOR {
    var vd = arg_vd;
    _ = &vd;
    var va = arg_va;
    _ = &va;
    var vb = arg_vb;
    _ = &vb;
    vd.*.x = va.*.x - vb.*.x;
    vd.*.y = va.*.y - vb.*.y;
    vd.*.z = va.*.z - vb.*.z;
    return vd;
}
pub fn vec_mul(arg_vd: [*c]VECTOR, arg_va: [*c]const VECTOR, arg_vb: [*c]const VECTOR) callconv(.c) [*c]VECTOR {
    var vd = arg_vd;
    _ = &vd;
    var va = arg_va;
    _ = &va;
    var vb = arg_vb;
    _ = &vb;
    vd.*.x = fxmul(va.*.x, vb.*.x);
    vd.*.y = fxmul(va.*.y, vb.*.y);
    vd.*.z = fxmul(va.*.z, vb.*.z);
    return vd;
}
pub fn vec_scale(arg_vd: [*c]VECTOR, arg_va: [*c]const VECTOR, arg_c: FIXED) callconv(.c) [*c]VECTOR {
    var vd = arg_vd;
    _ = &vd;
    var va = arg_va;
    _ = &va;
    var c = arg_c;
    _ = &c;
    vd.*.x = fxmul(va.*.x, c);
    vd.*.y = fxmul(va.*.y, c);
    vd.*.z = fxmul(va.*.z, c);
    return vd;
}
pub fn vec_dot(arg_va: [*c]const VECTOR, arg_vb: [*c]const VECTOR) callconv(.c) FIXED {
    var va = arg_va;
    _ = &va;
    var vb = arg_vb;
    _ = &vb;
    var dot: FIXED = undefined;
    _ = &dot;
    dot = fxmul(va.*.x, vb.*.x);
    dot += fxmul(va.*.y, vb.*.y);
    dot += fxmul(va.*.z, vb.*.z);
    return dot;
}
pub fn vec_add_eq(arg_vd: [*c]VECTOR, arg_vb: [*c]const VECTOR) callconv(.c) [*c]VECTOR {
    var vd = arg_vd;
    _ = &vd;
    var vb = arg_vb;
    _ = &vb;
    vd.*.x += vb.*.x;
    vd.*.y += vb.*.y;
    vd.*.z += vb.*.z;
    return vd;
}
pub fn vec_sub_eq(arg_vd: [*c]VECTOR, arg_vb: [*c]const VECTOR) callconv(.c) [*c]VECTOR {
    var vd = arg_vd;
    _ = &vd;
    var vb = arg_vb;
    _ = &vb;
    vd.*.x -= vb.*.x;
    vd.*.y -= vb.*.y;
    vd.*.z -= vb.*.z;
    return vd;
}
pub fn vec_mul_eq(arg_vd: [*c]VECTOR, arg_vb: [*c]const VECTOR) callconv(.c) [*c]VECTOR {
    var vd = arg_vd;
    _ = &vd;
    var vb = arg_vb;
    _ = &vb;
    vd.*.x = fxmul(vd.*.x, vb.*.x);
    vd.*.y = fxmul(vd.*.y, vb.*.y);
    vd.*.z = fxmul(vd.*.z, vb.*.z);
    return vd;
}
pub fn vec_scale_eq(arg_vd: [*c]VECTOR, arg_c: FIXED) callconv(.c) [*c]VECTOR {
    var vd = arg_vd;
    _ = &vd;
    var c = arg_c;
    _ = &c;
    vd.*.x = fxmul(vd.*.x, c);
    vd.*.y = fxmul(vd.*.y, c);
    vd.*.z = fxmul(vd.*.z, c);
    return vd;
}
pub extern fn vec_cross(vd: [*c]VECTOR, va: [*c]const VECTOR, vb: [*c]const VECTOR) [*c]VECTOR;
pub const __llvm__ = @as(c_int, 1);
pub const __clang__ = @as(c_int, 1);
pub const __clang_major__ = @as(c_int, 19);
pub const __clang_minor__ = @as(c_int, 1);
pub const __clang_patchlevel__ = @as(c_int, 7);
pub const __clang_version__ = "19.1.7 (https://github.com/ziglang/zig-bootstrap de1b01a8c1dddf75a560123ac1c2ab182b4830da)";
pub const __GNUC__ = @as(c_int, 4);
pub const __GNUC_MINOR__ = @as(c_int, 2);
pub const __GNUC_PATCHLEVEL__ = @as(c_int, 1);
pub const __GXX_ABI_VERSION = @as(c_int, 1002);
pub const __ATOMIC_RELAXED = @as(c_int, 0);
pub const __ATOMIC_CONSUME = @as(c_int, 1);
pub const __ATOMIC_ACQUIRE = @as(c_int, 2);
pub const __ATOMIC_RELEASE = @as(c_int, 3);
pub const __ATOMIC_ACQ_REL = @as(c_int, 4);
pub const __ATOMIC_SEQ_CST = @as(c_int, 5);
pub const __MEMORY_SCOPE_SYSTEM = @as(c_int, 0);
pub const __MEMORY_SCOPE_DEVICE = @as(c_int, 1);
pub const __MEMORY_SCOPE_WRKGRP = @as(c_int, 2);
pub const __MEMORY_SCOPE_WVFRNT = @as(c_int, 3);
pub const __MEMORY_SCOPE_SINGLE = @as(c_int, 4);
pub const __OPENCL_MEMORY_SCOPE_WORK_ITEM = @as(c_int, 0);
pub const __OPENCL_MEMORY_SCOPE_WORK_GROUP = @as(c_int, 1);
pub const __OPENCL_MEMORY_SCOPE_DEVICE = @as(c_int, 2);
pub const __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES = @as(c_int, 3);
pub const __OPENCL_MEMORY_SCOPE_SUB_GROUP = @as(c_int, 4);
pub const __FPCLASS_SNAN = @as(c_int, 0x0001);
pub const __FPCLASS_QNAN = @as(c_int, 0x0002);
pub const __FPCLASS_NEGINF = @as(c_int, 0x0004);
pub const __FPCLASS_NEGNORMAL = @as(c_int, 0x0008);
pub const __FPCLASS_NEGSUBNORMAL = @as(c_int, 0x0010);
pub const __FPCLASS_NEGZERO = @as(c_int, 0x0020);
pub const __FPCLASS_POSZERO = @as(c_int, 0x0040);
pub const __FPCLASS_POSSUBNORMAL = @as(c_int, 0x0080);
pub const __FPCLASS_POSNORMAL = @as(c_int, 0x0100);
pub const __FPCLASS_POSINF = @as(c_int, 0x0200);
pub const __PRAGMA_REDEFINE_EXTNAME = @as(c_int, 1);
pub const __VERSION__ = "Clang 19.1.7 (https://github.com/ziglang/zig-bootstrap de1b01a8c1dddf75a560123ac1c2ab182b4830da)";
pub const __GXX_TYPEINFO_EQUALITY_INLINE = @as(c_int, 0);
pub const __OBJC_BOOL_IS_BOOL = @as(c_int, 0);
pub const __CONSTANT_CFSTRINGS__ = @as(c_int, 1);
pub const __SEH__ = @as(c_int, 1);
pub const __clang_literal_encoding__ = "UTF-8";
pub const __clang_wide_literal_encoding__ = "UTF-16";
pub const __ORDER_LITTLE_ENDIAN__ = @as(c_int, 1234);
pub const __ORDER_BIG_ENDIAN__ = @as(c_int, 4321);
pub const __ORDER_PDP_ENDIAN__ = @as(c_int, 3412);
pub const __BYTE_ORDER__ = __ORDER_LITTLE_ENDIAN__;
pub const __LITTLE_ENDIAN__ = @as(c_int, 1);
pub const __CHAR_BIT__ = @as(c_int, 8);
pub const __BOOL_WIDTH__ = @as(c_int, 8);
pub const __SHRT_WIDTH__ = @as(c_int, 16);
pub const __INT_WIDTH__ = @as(c_int, 32);
pub const __LONG_WIDTH__ = @as(c_int, 32);
pub const __LLONG_WIDTH__ = @as(c_int, 64);
pub const __BITINT_MAXWIDTH__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 8388608, .decimal);
pub const __SCHAR_MAX__ = @as(c_int, 127);
pub const __SHRT_MAX__ = @as(c_int, 32767);
pub const __INT_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __LONG_MAX__ = @as(c_long, 2147483647);
pub const __LONG_LONG_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __WCHAR_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __WCHAR_WIDTH__ = @as(c_int, 16);
pub const __WINT_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __WINT_WIDTH__ = @as(c_int, 16);
pub const __INTMAX_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __INTMAX_WIDTH__ = @as(c_int, 64);
pub const __SIZE_MAX__ = @as(c_ulonglong, 18446744073709551615);
pub const __SIZE_WIDTH__ = @as(c_int, 64);
pub const __UINTMAX_MAX__ = @as(c_ulonglong, 18446744073709551615);
pub const __UINTMAX_WIDTH__ = @as(c_int, 64);
pub const __PTRDIFF_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __PTRDIFF_WIDTH__ = @as(c_int, 64);
pub const __INTPTR_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __INTPTR_WIDTH__ = @as(c_int, 64);
pub const __UINTPTR_MAX__ = @as(c_ulonglong, 18446744073709551615);
pub const __UINTPTR_WIDTH__ = @as(c_int, 64);
pub const __SIZEOF_DOUBLE__ = @as(c_int, 8);
pub const __SIZEOF_FLOAT__ = @as(c_int, 4);
pub const __SIZEOF_INT__ = @as(c_int, 4);
pub const __SIZEOF_LONG__ = @as(c_int, 4);
pub const __SIZEOF_LONG_DOUBLE__ = @as(c_int, 16);
pub const __SIZEOF_LONG_LONG__ = @as(c_int, 8);
pub const __SIZEOF_POINTER__ = @as(c_int, 8);
pub const __SIZEOF_SHORT__ = @as(c_int, 2);
pub const __SIZEOF_PTRDIFF_T__ = @as(c_int, 8);
pub const __SIZEOF_SIZE_T__ = @as(c_int, 8);
pub const __SIZEOF_WCHAR_T__ = @as(c_int, 2);
pub const __SIZEOF_WINT_T__ = @as(c_int, 2);
pub const __SIZEOF_INT128__ = @as(c_int, 16);
pub const __INTMAX_TYPE__ = c_longlong;
pub const __INTMAX_FMTd__ = "lld";
pub const __INTMAX_FMTi__ = "lli";
pub const __INTMAX_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `LL`");
// (no file):95:9
pub const __UINTMAX_TYPE__ = c_ulonglong;
pub const __UINTMAX_FMTo__ = "llo";
pub const __UINTMAX_FMTu__ = "llu";
pub const __UINTMAX_FMTx__ = "llx";
pub const __UINTMAX_FMTX__ = "llX";
pub const __UINTMAX_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `ULL`");
// (no file):101:9
pub const __PTRDIFF_TYPE__ = c_longlong;
pub const __PTRDIFF_FMTd__ = "lld";
pub const __PTRDIFF_FMTi__ = "lli";
pub const __INTPTR_TYPE__ = c_longlong;
pub const __INTPTR_FMTd__ = "lld";
pub const __INTPTR_FMTi__ = "lli";
pub const __SIZE_TYPE__ = c_ulonglong;
pub const __SIZE_FMTo__ = "llo";
pub const __SIZE_FMTu__ = "llu";
pub const __SIZE_FMTx__ = "llx";
pub const __SIZE_FMTX__ = "llX";
pub const __WCHAR_TYPE__ = c_ushort;
pub const __WINT_TYPE__ = c_ushort;
pub const __SIG_ATOMIC_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __SIG_ATOMIC_WIDTH__ = @as(c_int, 32);
pub const __CHAR16_TYPE__ = c_ushort;
pub const __CHAR32_TYPE__ = c_uint;
pub const __UINTPTR_TYPE__ = c_ulonglong;
pub const __UINTPTR_FMTo__ = "llo";
pub const __UINTPTR_FMTu__ = "llu";
pub const __UINTPTR_FMTx__ = "llx";
pub const __UINTPTR_FMTX__ = "llX";
pub const __FLT16_DENORM_MIN__ = @as(f16, 5.9604644775390625e-8);
pub const __FLT16_NORM_MAX__ = @as(f16, 6.5504e+4);
pub const __FLT16_HAS_DENORM__ = @as(c_int, 1);
pub const __FLT16_DIG__ = @as(c_int, 3);
pub const __FLT16_DECIMAL_DIG__ = @as(c_int, 5);
pub const __FLT16_EPSILON__ = @as(f16, 9.765625e-4);
pub const __FLT16_HAS_INFINITY__ = @as(c_int, 1);
pub const __FLT16_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __FLT16_MANT_DIG__ = @as(c_int, 11);
pub const __FLT16_MAX_10_EXP__ = @as(c_int, 4);
pub const __FLT16_MAX_EXP__ = @as(c_int, 16);
pub const __FLT16_MAX__ = @as(f16, 6.5504e+4);
pub const __FLT16_MIN_10_EXP__ = -@as(c_int, 4);
pub const __FLT16_MIN_EXP__ = -@as(c_int, 13);
pub const __FLT16_MIN__ = @as(f16, 6.103515625e-5);
pub const __FLT_DENORM_MIN__ = @as(f32, 1.40129846e-45);
pub const __FLT_NORM_MAX__ = @as(f32, 3.40282347e+38);
pub const __FLT_HAS_DENORM__ = @as(c_int, 1);
pub const __FLT_DIG__ = @as(c_int, 6);
pub const __FLT_DECIMAL_DIG__ = @as(c_int, 9);
pub const __FLT_EPSILON__ = @as(f32, 1.19209290e-7);
pub const __FLT_HAS_INFINITY__ = @as(c_int, 1);
pub const __FLT_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __FLT_MANT_DIG__ = @as(c_int, 24);
pub const __FLT_MAX_10_EXP__ = @as(c_int, 38);
pub const __FLT_MAX_EXP__ = @as(c_int, 128);
pub const __FLT_MAX__ = @as(f32, 3.40282347e+38);
pub const __FLT_MIN_10_EXP__ = -@as(c_int, 37);
pub const __FLT_MIN_EXP__ = -@as(c_int, 125);
pub const __FLT_MIN__ = @as(f32, 1.17549435e-38);
pub const __DBL_DENORM_MIN__ = @as(f64, 4.9406564584124654e-324);
pub const __DBL_NORM_MAX__ = @as(f64, 1.7976931348623157e+308);
pub const __DBL_HAS_DENORM__ = @as(c_int, 1);
pub const __DBL_DIG__ = @as(c_int, 15);
pub const __DBL_DECIMAL_DIG__ = @as(c_int, 17);
pub const __DBL_EPSILON__ = @as(f64, 2.2204460492503131e-16);
pub const __DBL_HAS_INFINITY__ = @as(c_int, 1);
pub const __DBL_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __DBL_MANT_DIG__ = @as(c_int, 53);
pub const __DBL_MAX_10_EXP__ = @as(c_int, 308);
pub const __DBL_MAX_EXP__ = @as(c_int, 1024);
pub const __DBL_MAX__ = @as(f64, 1.7976931348623157e+308);
pub const __DBL_MIN_10_EXP__ = -@as(c_int, 307);
pub const __DBL_MIN_EXP__ = -@as(c_int, 1021);
pub const __DBL_MIN__ = @as(f64, 2.2250738585072014e-308);
pub const __LDBL_DENORM_MIN__ = @as(c_longdouble, 3.64519953188247460253e-4951);
pub const __LDBL_NORM_MAX__ = @as(c_longdouble, 1.18973149535723176502e+4932);
pub const __LDBL_HAS_DENORM__ = @as(c_int, 1);
pub const __LDBL_DIG__ = @as(c_int, 18);
pub const __LDBL_DECIMAL_DIG__ = @as(c_int, 21);
pub const __LDBL_EPSILON__ = @as(c_longdouble, 1.08420217248550443401e-19);
pub const __LDBL_HAS_INFINITY__ = @as(c_int, 1);
pub const __LDBL_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __LDBL_MANT_DIG__ = @as(c_int, 64);
pub const __LDBL_MAX_10_EXP__ = @as(c_int, 4932);
pub const __LDBL_MAX_EXP__ = @as(c_int, 16384);
pub const __LDBL_MAX__ = @as(c_longdouble, 1.18973149535723176502e+4932);
pub const __LDBL_MIN_10_EXP__ = -@as(c_int, 4931);
pub const __LDBL_MIN_EXP__ = -@as(c_int, 16381);
pub const __LDBL_MIN__ = @as(c_longdouble, 3.36210314311209350626e-4932);
pub const __POINTER_WIDTH__ = @as(c_int, 64);
pub const __BIGGEST_ALIGNMENT__ = @as(c_int, 16);
pub const __WCHAR_UNSIGNED__ = @as(c_int, 1);
pub const __WINT_UNSIGNED__ = @as(c_int, 1);
pub const __INT8_TYPE__ = i8;
pub const __INT8_FMTd__ = "hhd";
pub const __INT8_FMTi__ = "hhi";
pub const __INT8_C_SUFFIX__ = "";
pub const __INT16_TYPE__ = c_short;
pub const __INT16_FMTd__ = "hd";
pub const __INT16_FMTi__ = "hi";
pub const __INT16_C_SUFFIX__ = "";
pub const __INT32_TYPE__ = c_int;
pub const __INT32_FMTd__ = "d";
pub const __INT32_FMTi__ = "i";
pub const __INT32_C_SUFFIX__ = "";
pub const __INT64_TYPE__ = c_longlong;
pub const __INT64_FMTd__ = "lld";
pub const __INT64_FMTi__ = "lli";
pub const __INT64_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `LL`");
// (no file):203:9
pub const __UINT8_TYPE__ = u8;
pub const __UINT8_FMTo__ = "hho";
pub const __UINT8_FMTu__ = "hhu";
pub const __UINT8_FMTx__ = "hhx";
pub const __UINT8_FMTX__ = "hhX";
pub const __UINT8_C_SUFFIX__ = "";
pub const __UINT8_MAX__ = @as(c_int, 255);
pub const __INT8_MAX__ = @as(c_int, 127);
pub const __UINT16_TYPE__ = c_ushort;
pub const __UINT16_FMTo__ = "ho";
pub const __UINT16_FMTu__ = "hu";
pub const __UINT16_FMTx__ = "hx";
pub const __UINT16_FMTX__ = "hX";
pub const __UINT16_C_SUFFIX__ = "";
pub const __UINT16_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __INT16_MAX__ = @as(c_int, 32767);
pub const __UINT32_TYPE__ = c_uint;
pub const __UINT32_FMTo__ = "o";
pub const __UINT32_FMTu__ = "u";
pub const __UINT32_FMTx__ = "x";
pub const __UINT32_FMTX__ = "X";
pub const __UINT32_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `U`");
// (no file):225:9
pub const __UINT32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __INT32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __UINT64_TYPE__ = c_ulonglong;
pub const __UINT64_FMTo__ = "llo";
pub const __UINT64_FMTu__ = "llu";
pub const __UINT64_FMTx__ = "llx";
pub const __UINT64_FMTX__ = "llX";
pub const __UINT64_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `ULL`");
// (no file):233:9
pub const __UINT64_MAX__ = @as(c_ulonglong, 18446744073709551615);
pub const __INT64_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __INT_LEAST8_TYPE__ = i8;
pub const __INT_LEAST8_MAX__ = @as(c_int, 127);
pub const __INT_LEAST8_WIDTH__ = @as(c_int, 8);
pub const __INT_LEAST8_FMTd__ = "hhd";
pub const __INT_LEAST8_FMTi__ = "hhi";
pub const __UINT_LEAST8_TYPE__ = u8;
pub const __UINT_LEAST8_MAX__ = @as(c_int, 255);
pub const __UINT_LEAST8_FMTo__ = "hho";
pub const __UINT_LEAST8_FMTu__ = "hhu";
pub const __UINT_LEAST8_FMTx__ = "hhx";
pub const __UINT_LEAST8_FMTX__ = "hhX";
pub const __INT_LEAST16_TYPE__ = c_short;
pub const __INT_LEAST16_MAX__ = @as(c_int, 32767);
pub const __INT_LEAST16_WIDTH__ = @as(c_int, 16);
pub const __INT_LEAST16_FMTd__ = "hd";
pub const __INT_LEAST16_FMTi__ = "hi";
pub const __UINT_LEAST16_TYPE__ = c_ushort;
pub const __UINT_LEAST16_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __UINT_LEAST16_FMTo__ = "ho";
pub const __UINT_LEAST16_FMTu__ = "hu";
pub const __UINT_LEAST16_FMTx__ = "hx";
pub const __UINT_LEAST16_FMTX__ = "hX";
pub const __INT_LEAST32_TYPE__ = c_int;
pub const __INT_LEAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __INT_LEAST32_WIDTH__ = @as(c_int, 32);
pub const __INT_LEAST32_FMTd__ = "d";
pub const __INT_LEAST32_FMTi__ = "i";
pub const __UINT_LEAST32_TYPE__ = c_uint;
pub const __UINT_LEAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __UINT_LEAST32_FMTo__ = "o";
pub const __UINT_LEAST32_FMTu__ = "u";
pub const __UINT_LEAST32_FMTx__ = "x";
pub const __UINT_LEAST32_FMTX__ = "X";
pub const __INT_LEAST64_TYPE__ = c_longlong;
pub const __INT_LEAST64_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __INT_LEAST64_WIDTH__ = @as(c_int, 64);
pub const __INT_LEAST64_FMTd__ = "lld";
pub const __INT_LEAST64_FMTi__ = "lli";
pub const __UINT_LEAST64_TYPE__ = c_ulonglong;
pub const __UINT_LEAST64_MAX__ = @as(c_ulonglong, 18446744073709551615);
pub const __UINT_LEAST64_FMTo__ = "llo";
pub const __UINT_LEAST64_FMTu__ = "llu";
pub const __UINT_LEAST64_FMTx__ = "llx";
pub const __UINT_LEAST64_FMTX__ = "llX";
pub const __INT_FAST8_TYPE__ = i8;
pub const __INT_FAST8_MAX__ = @as(c_int, 127);
pub const __INT_FAST8_WIDTH__ = @as(c_int, 8);
pub const __INT_FAST8_FMTd__ = "hhd";
pub const __INT_FAST8_FMTi__ = "hhi";
pub const __UINT_FAST8_TYPE__ = u8;
pub const __UINT_FAST8_MAX__ = @as(c_int, 255);
pub const __UINT_FAST8_FMTo__ = "hho";
pub const __UINT_FAST8_FMTu__ = "hhu";
pub const __UINT_FAST8_FMTx__ = "hhx";
pub const __UINT_FAST8_FMTX__ = "hhX";
pub const __INT_FAST16_TYPE__ = c_short;
pub const __INT_FAST16_MAX__ = @as(c_int, 32767);
pub const __INT_FAST16_WIDTH__ = @as(c_int, 16);
pub const __INT_FAST16_FMTd__ = "hd";
pub const __INT_FAST16_FMTi__ = "hi";
pub const __UINT_FAST16_TYPE__ = c_ushort;
pub const __UINT_FAST16_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __UINT_FAST16_FMTo__ = "ho";
pub const __UINT_FAST16_FMTu__ = "hu";
pub const __UINT_FAST16_FMTx__ = "hx";
pub const __UINT_FAST16_FMTX__ = "hX";
pub const __INT_FAST32_TYPE__ = c_int;
pub const __INT_FAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __INT_FAST32_WIDTH__ = @as(c_int, 32);
pub const __INT_FAST32_FMTd__ = "d";
pub const __INT_FAST32_FMTi__ = "i";
pub const __UINT_FAST32_TYPE__ = c_uint;
pub const __UINT_FAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __UINT_FAST32_FMTo__ = "o";
pub const __UINT_FAST32_FMTu__ = "u";
pub const __UINT_FAST32_FMTx__ = "x";
pub const __UINT_FAST32_FMTX__ = "X";
pub const __INT_FAST64_TYPE__ = c_longlong;
pub const __INT_FAST64_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __INT_FAST64_WIDTH__ = @as(c_int, 64);
pub const __INT_FAST64_FMTd__ = "lld";
pub const __INT_FAST64_FMTi__ = "lli";
pub const __UINT_FAST64_TYPE__ = c_ulonglong;
pub const __UINT_FAST64_MAX__ = @as(c_ulonglong, 18446744073709551615);
pub const __UINT_FAST64_FMTo__ = "llo";
pub const __UINT_FAST64_FMTu__ = "llu";
pub const __UINT_FAST64_FMTx__ = "llx";
pub const __UINT_FAST64_FMTX__ = "llX";
pub const __USER_LABEL_PREFIX__ = "";
pub const __FINITE_MATH_ONLY__ = @as(c_int, 0);
pub const __GNUC_STDC_INLINE__ = @as(c_int, 1);
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL = @as(c_int, 1);
pub const __GCC_DESTRUCTIVE_SIZE = @as(c_int, 64);
pub const __GCC_CONSTRUCTIVE_SIZE = @as(c_int, 64);
pub const __CLANG_ATOMIC_BOOL_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_CHAR_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_CHAR16_T_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_CHAR32_T_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_WCHAR_T_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_SHORT_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_INT_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_LONG_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_LLONG_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_POINTER_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_BOOL_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_CHAR_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_SHORT_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_INT_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_LONG_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_LLONG_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_POINTER_LOCK_FREE = @as(c_int, 2);
pub const __NO_INLINE__ = @as(c_int, 1);
pub const __PIC__ = @as(c_int, 2);
pub const __pic__ = @as(c_int, 2);
pub const __FLT_RADIX__ = @as(c_int, 2);
pub const __DECIMAL_DIG__ = __LDBL_DECIMAL_DIG__;
pub const __SSP_STRONG__ = @as(c_int, 2);
pub const __GCC_ASM_FLAG_OUTPUTS__ = @as(c_int, 1);
pub const __code_model_small__ = @as(c_int, 1);
pub const __amd64__ = @as(c_int, 1);
pub const __amd64 = @as(c_int, 1);
pub const __x86_64 = @as(c_int, 1);
pub const __x86_64__ = @as(c_int, 1);
pub const __SEG_GS = @as(c_int, 1);
pub const __SEG_FS = @as(c_int, 1);
pub const __seg_gs = @compileError("unable to translate macro: undefined identifier `address_space`");
// (no file):366:9
pub const __seg_fs = @compileError("unable to translate macro: undefined identifier `address_space`");
// (no file):367:9
pub const __corei7 = @as(c_int, 1);
pub const __corei7__ = @as(c_int, 1);
pub const __tune_corei7__ = @as(c_int, 1);
pub const __REGISTER_PREFIX__ = "";
pub const __NO_MATH_INLINES = @as(c_int, 1);
pub const __AES__ = @as(c_int, 1);
pub const __VAES__ = @as(c_int, 1);
pub const __PCLMUL__ = @as(c_int, 1);
pub const __VPCLMULQDQ__ = @as(c_int, 1);
pub const __LAHF_SAHF__ = @as(c_int, 1);
pub const __LZCNT__ = @as(c_int, 1);
pub const __RDRND__ = @as(c_int, 1);
pub const __FSGSBASE__ = @as(c_int, 1);
pub const __BMI__ = @as(c_int, 1);
pub const __BMI2__ = @as(c_int, 1);
pub const __POPCNT__ = @as(c_int, 1);
pub const __PRFCHW__ = @as(c_int, 1);
pub const __RDSEED__ = @as(c_int, 1);
pub const __ADX__ = @as(c_int, 1);
pub const __MOVBE__ = @as(c_int, 1);
pub const __FMA__ = @as(c_int, 1);
pub const __F16C__ = @as(c_int, 1);
pub const __GFNI__ = @as(c_int, 1);
pub const __SHA__ = @as(c_int, 1);
pub const __FXSR__ = @as(c_int, 1);
pub const __XSAVE__ = @as(c_int, 1);
pub const __XSAVEOPT__ = @as(c_int, 1);
pub const __XSAVEC__ = @as(c_int, 1);
pub const __XSAVES__ = @as(c_int, 1);
pub const __CLFLUSHOPT__ = @as(c_int, 1);
pub const __CLWB__ = @as(c_int, 1);
pub const __SHSTK__ = @as(c_int, 1);
pub const __RDPID__ = @as(c_int, 1);
pub const __WAITPKG__ = @as(c_int, 1);
pub const __MOVDIRI__ = @as(c_int, 1);
pub const __MOVDIR64B__ = @as(c_int, 1);
pub const __PTWRITE__ = @as(c_int, 1);
pub const __INVPCID__ = @as(c_int, 1);
pub const __HRESET__ = @as(c_int, 1);
pub const __AVXVNNI__ = @as(c_int, 1);
pub const __SERIALIZE__ = @as(c_int, 1);
pub const __CRC32__ = @as(c_int, 1);
pub const __AVX2__ = @as(c_int, 1);
pub const __AVX__ = @as(c_int, 1);
pub const __SSE4_2__ = @as(c_int, 1);
pub const __SSE4_1__ = @as(c_int, 1);
pub const __SSSE3__ = @as(c_int, 1);
pub const __SSE3__ = @as(c_int, 1);
pub const __SSE2__ = @as(c_int, 1);
pub const __SSE2_MATH__ = @as(c_int, 1);
pub const __SSE__ = @as(c_int, 1);
pub const __SSE_MATH__ = @as(c_int, 1);
pub const __MMX__ = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_16 = @as(c_int, 1);
pub const __SIZEOF_FLOAT128__ = @as(c_int, 16);
pub const _WIN32 = @as(c_int, 1);
pub const _WIN64 = @as(c_int, 1);
pub const WIN32 = @as(c_int, 1);
pub const __WIN32 = @as(c_int, 1);
pub const __WIN32__ = @as(c_int, 1);
pub const WINNT = @as(c_int, 1);
pub const __WINNT = @as(c_int, 1);
pub const __WINNT__ = @as(c_int, 1);
pub const WIN64 = @as(c_int, 1);
pub const __WIN64 = @as(c_int, 1);
pub const __WIN64__ = @as(c_int, 1);
pub const __MINGW64__ = @as(c_int, 1);
pub const __MSVCRT__ = @as(c_int, 1);
pub const __MINGW32__ = @as(c_int, 1);
pub const __declspec = @compileError("unable to translate C expr: unexpected token '__attribute__'");
// (no file):441:9
pub const _cdecl = @compileError("unable to translate macro: undefined identifier `__cdecl__`");
// (no file):442:9
pub const __cdecl = @compileError("unable to translate macro: undefined identifier `__cdecl__`");
// (no file):443:9
pub const _stdcall = @compileError("unable to translate macro: undefined identifier `__stdcall__`");
// (no file):444:9
pub const __stdcall = @compileError("unable to translate macro: undefined identifier `__stdcall__`");
// (no file):445:9
pub const _fastcall = @compileError("unable to translate macro: undefined identifier `__fastcall__`");
// (no file):446:9
pub const __fastcall = @compileError("unable to translate macro: undefined identifier `__fastcall__`");
// (no file):447:9
pub const _thiscall = @compileError("unable to translate macro: undefined identifier `__thiscall__`");
// (no file):448:9
pub const __thiscall = @compileError("unable to translate macro: undefined identifier `__thiscall__`");
// (no file):449:9
pub const _pascal = @compileError("unable to translate macro: undefined identifier `__pascal__`");
// (no file):450:9
pub const __pascal = @compileError("unable to translate macro: undefined identifier `__pascal__`");
// (no file):451:9
pub const __STDC__ = @as(c_int, 1);
pub const __STDC_HOSTED__ = @as(c_int, 1);
pub const __STDC_VERSION__ = @as(c_long, 201710);
pub const __STDC_UTF_16__ = @as(c_int, 1);
pub const __STDC_UTF_32__ = @as(c_int, 1);
pub const __STDC_EMBED_NOT_FOUND__ = @as(c_int, 0);
pub const __STDC_EMBED_FOUND__ = @as(c_int, 1);
pub const __STDC_EMBED_EMPTY__ = @as(c_int, 2);
pub const _DEBUG = @as(c_int, 1);
pub const __MSVCRT_VERSION__ = @as(c_int, 0xE00);
pub const _WIN32_WINNT = @as(c_int, 0x0a00);
pub const TONC_MEMMAP = "";
pub const TONC_TYPES = "";
pub const __CLANG_STDINT_H = "";
pub const _STDINT_H = "";
pub const _INC_CRTDEFS = "";
pub const _INC_CORECRT = "";
pub const _INC__MINGW_H = "";
pub const _INC_CRTDEFS_MACRO = "";
pub const __MINGW64_PASTE2 = @compileError("unable to translate C expr: unexpected token '##'");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw_mac.h:10:9
pub inline fn __MINGW64_PASTE(x: anytype, y: anytype) @TypeOf(__MINGW64_PASTE2(x, y)) {
    _ = &x;
    _ = &y;
    return __MINGW64_PASTE2(x, y);
}
pub const __STRINGIFY = @compileError("unable to translate C expr: unexpected token '#'");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw_mac.h:13:9
pub inline fn __MINGW64_STRINGIFY(x: anytype) @TypeOf(__STRINGIFY(x)) {
    _ = &x;
    return __STRINGIFY(x);
}
pub const __MINGW64_VERSION_MAJOR = @as(c_int, 13);
pub const __MINGW64_VERSION_MINOR = @as(c_int, 0);
pub const __MINGW64_VERSION_BUGFIX = @as(c_int, 0);
pub const __MINGW64_VERSION_RC = @as(c_int, 0);
pub const __MINGW64_VERSION_STR = __MINGW64_STRINGIFY(__MINGW64_VERSION_MAJOR) ++ "." ++ __MINGW64_STRINGIFY(__MINGW64_VERSION_MINOR) ++ "." ++ __MINGW64_STRINGIFY(__MINGW64_VERSION_BUGFIX);
pub const __MINGW64_VERSION_STATE = "alpha";
pub const __MINGW32_MAJOR_VERSION = @as(c_int, 3);
pub const __MINGW32_MINOR_VERSION = @as(c_int, 11);
pub const _M_AMD64 = @as(c_int, 100);
pub const _M_X64 = @as(c_int, 100);
pub const @"_" = @as(c_int, 1);
pub const __MINGW_USE_UNDERSCORE_PREFIX = @as(c_int, 0);
pub const __MINGW_IMP_SYMBOL = @compileError("unable to translate macro: undefined identifier `__imp_`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw_mac.h:129:11
pub const __MINGW_IMP_LSYMBOL = @compileError("unable to translate macro: undefined identifier `__imp_`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw_mac.h:130:11
pub inline fn __MINGW_USYMBOL(sym: anytype) @TypeOf(sym) {
    _ = &sym;
    return sym;
}
pub inline fn __MINGW_LSYMBOL(sym: anytype) @TypeOf(__MINGW64_PASTE(@"_", sym)) {
    _ = &sym;
    return __MINGW64_PASTE(@"_", sym);
}
pub const __MINGW_ASM_CALL = @compileError("unable to translate C expr: unexpected token '__asm__'");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw_mac.h:140:9
pub const __MINGW_ASM_CRT_CALL = @compileError("unable to translate C expr: unexpected token '__asm__'");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw_mac.h:141:9
pub const __MINGW_EXTENSION = @compileError("unable to translate C expr: unexpected token '__extension__'");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw_mac.h:173:13
pub const __C89_NAMELESS = __MINGW_EXTENSION;
pub const __C89_NAMELESSSTRUCTNAME = "";
pub const __C89_NAMELESSSTRUCTNAME1 = "";
pub const __C89_NAMELESSSTRUCTNAME2 = "";
pub const __C89_NAMELESSSTRUCTNAME3 = "";
pub const __C89_NAMELESSSTRUCTNAME4 = "";
pub const __C89_NAMELESSSTRUCTNAME5 = "";
pub const __C89_NAMELESSUNIONNAME = "";
pub const __C89_NAMELESSUNIONNAME1 = "";
pub const __C89_NAMELESSUNIONNAME2 = "";
pub const __C89_NAMELESSUNIONNAME3 = "";
pub const __C89_NAMELESSUNIONNAME4 = "";
pub const __C89_NAMELESSUNIONNAME5 = "";
pub const __C89_NAMELESSUNIONNAME6 = "";
pub const __C89_NAMELESSUNIONNAME7 = "";
pub const __C89_NAMELESSUNIONNAME8 = "";
pub const __GNU_EXTENSION = __MINGW_EXTENSION;
pub const __MINGW_HAVE_ANSI_C99_PRINTF = @as(c_int, 1);
pub const __MINGW_HAVE_WIDE_C99_PRINTF = @as(c_int, 1);
pub const __MINGW_HAVE_ANSI_C99_SCANF = @as(c_int, 1);
pub const __MINGW_HAVE_WIDE_C99_SCANF = @as(c_int, 1);
pub const __MINGW_POISON_NAME = @compileError("unable to translate macro: undefined identifier `_layout_has_not_been_verified_and_its_declaration_is_most_likely_incorrect`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw_mac.h:213:11
pub const __MSABI_LONG = @import("std").zig.c_translation.Macros.L_SUFFIX;
pub const __MINGW_GCC_VERSION = ((__GNUC__ * @as(c_int, 10000)) + (__GNUC_MINOR__ * @as(c_int, 100))) + __GNUC_PATCHLEVEL__;
pub inline fn __MINGW_GNUC_PREREQ(major: anytype, minor: anytype) @TypeOf((__GNUC__ > major) or ((__GNUC__ == major) and (__GNUC_MINOR__ >= minor))) {
    _ = &major;
    _ = &minor;
    return (__GNUC__ > major) or ((__GNUC__ == major) and (__GNUC_MINOR__ >= minor));
}
pub inline fn __MINGW_MSC_PREREQ(major: anytype, minor: anytype) @TypeOf(@as(c_int, 0)) {
    _ = &major;
    _ = &minor;
    return @as(c_int, 0);
}
pub const __MINGW_ATTRIB_DEPRECATED_STR = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw_mac.h:257:11
pub const __MINGW_SEC_WARN_STR = "This function or variable may be unsafe, use _CRT_SECURE_NO_WARNINGS to disable deprecation";
pub const __MINGW_MSVC2005_DEPREC_STR = "This POSIX function is deprecated beginning in Visual C++ 2005, use _CRT_NONSTDC_NO_DEPRECATE to disable deprecation";
pub const __MINGW_ATTRIB_DEPRECATED_MSVC2005 = __MINGW_ATTRIB_DEPRECATED_STR(__MINGW_MSVC2005_DEPREC_STR);
pub const __MINGW_ATTRIB_DEPRECATED_SEC_WARN = __MINGW_ATTRIB_DEPRECATED_STR(__MINGW_SEC_WARN_STR);
pub const __MINGW_MS_PRINTF = @compileError("unable to translate macro: undefined identifier `__format__`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw_mac.h:281:9
pub const __MINGW_MS_SCANF = @compileError("unable to translate macro: undefined identifier `__format__`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw_mac.h:284:9
pub const __MINGW_GNU_PRINTF = @compileError("unable to translate macro: undefined identifier `__format__`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw_mac.h:287:9
pub const __MINGW_GNU_SCANF = @compileError("unable to translate macro: undefined identifier `__format__`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw_mac.h:290:9
pub const __mingw_ovr = @compileError("unable to translate macro: undefined identifier `__unused__`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw_mac.h:311:11
pub const __mingw_attribute_artificial = @compileError("unable to translate macro: undefined identifier `__artificial__`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw_mac.h:318:11
pub const __MINGW_SELECTANY = @compileError("unable to translate macro: undefined identifier `__selectany__`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw_mac.h:324:9
pub const __MINGW_FORTIFY_LEVEL = @as(c_int, 0);
pub const __mingw_bos_ovr = __mingw_ovr;
pub const __MINGW_FORTIFY_VA_ARG = @as(c_int, 0);
pub const _INC_MINGW_SECAPI = "";
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES = @as(c_int, 0);
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY = @as(c_int, 0);
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES = @as(c_int, 0);
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT = @as(c_int, 0);
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY = @as(c_int, 0);
pub const __MINGW_CRT_NAME_CONCAT2 = @compileError("unable to translate macro: undefined identifier `_s`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw_secapi.h:41:9
pub const __CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY_0_3_ = @compileError("unable to translate C expr: unexpected token ';'");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw_secapi.h:69:9
pub const __LONG32 = c_long;
pub const __MINGW_IMPORT = @compileError("unable to translate macro: undefined identifier `__dllimport__`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:44:12
pub const __USE_CRTIMP = @as(c_int, 1);
pub const _CRTIMP = @compileError("unable to translate macro: undefined identifier `__dllimport__`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:52:15
pub const __DECLSPEC_SUPPORTED = "";
pub const USE___UUIDOF = @as(c_int, 0);
pub const _inline = @compileError("unable to translate C expr: unexpected token '__inline'");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:74:9
pub const __CRT_INLINE = @compileError("unable to translate macro: undefined identifier `__gnu_inline__`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:83:11
pub const __MINGW_INTRIN_INLINE = @compileError("unable to translate macro: undefined identifier `__always_inline__`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:90:9
pub const __CRT__NO_INLINE = @as(c_int, 1);
pub const __MINGW_CXX11_CONSTEXPR = "";
pub const __MINGW_CXX14_CONSTEXPR = "";
pub const __UNUSED_PARAM = @compileError("unable to translate macro: undefined identifier `__unused__`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:118:11
pub const __restrict_arr = @compileError("unable to translate C expr: unexpected token '__restrict'");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:133:10
pub const __MINGW_ATTRIB_NORETURN = @compileError("unable to translate macro: undefined identifier `__noreturn__`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:149:9
pub const __MINGW_ATTRIB_CONST = @compileError("unable to translate C expr: unexpected token '__attribute__'");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:150:9
pub const __MINGW_ATTRIB_MALLOC = @compileError("unable to translate macro: undefined identifier `__malloc__`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:160:9
pub const __MINGW_ATTRIB_PURE = @compileError("unable to translate macro: undefined identifier `__pure__`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:161:9
pub const __MINGW_ATTRIB_NONNULL = @compileError("unable to translate macro: undefined identifier `__nonnull__`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:174:9
pub const __MINGW_ATTRIB_UNUSED = @compileError("unable to translate macro: undefined identifier `__unused__`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:180:9
pub const __MINGW_ATTRIB_USED = @compileError("unable to translate macro: undefined identifier `__used__`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:186:9
pub const __MINGW_ATTRIB_DEPRECATED = @compileError("unable to translate macro: undefined identifier `__deprecated__`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:187:9
pub const __MINGW_ATTRIB_DEPRECATED_MSG = @compileError("unable to translate macro: undefined identifier `__deprecated__`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:189:9
pub const __MINGW_NOTHROW = @compileError("unable to translate macro: undefined identifier `__nothrow__`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:204:9
pub const __MINGW_ATTRIB_NO_OPTIMIZE = "";
pub const __MINGW_PRAGMA_PARAM = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:222:9
pub const __MINGW_BROKEN_INTERFACE = @compileError("unable to translate macro: undefined identifier `message`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:225:9
pub const _UCRT = "";
pub const _INT128_DEFINED = "";
pub const __int8 = u8;
pub const __int16 = c_short;
pub const __int32 = c_int;
pub const __int64 = c_longlong;
pub const __ptr32 = "";
pub const __ptr64 = "";
pub const __unaligned = "";
pub const __w64 = "";
pub const __forceinline = @compileError("unable to translate macro: undefined identifier `__always_inline__`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:284:9
pub const __nothrow = "";
pub const _INC_VADEFS = "";
pub const MINGW_SDK_INIT = "";
pub const MINGW_HAS_SECURE_API = @as(c_int, 1);
pub const __STDC_SECURE_LIB__ = @as(c_long, 200411);
pub const __GOT_SECURE_LIB__ = __STDC_SECURE_LIB__;
pub const MINGW_DDK_H = "";
pub const MINGW_HAS_DDK_H = @as(c_int, 1);
pub const _CRT_PACKING = @as(c_int, 8);
pub const __GNUC_VA_LIST = "";
pub const _VA_LIST_DEFINED = "";
pub inline fn _ADDRESSOF(v: anytype) @TypeOf(&v) {
    _ = &v;
    return &v;
}
pub const _crt_va_start = @compileError("unable to translate macro: undefined identifier `__builtin_va_start`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/vadefs.h:48:9
pub const _crt_va_arg = @compileError("unable to translate C expr: unexpected token 'an identifier'");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/vadefs.h:49:9
pub const _crt_va_end = @compileError("unable to translate macro: undefined identifier `__builtin_va_end`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/vadefs.h:50:9
pub const _crt_va_copy = @compileError("unable to translate macro: undefined identifier `__builtin_va_copy`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/vadefs.h:51:9
pub const __CRT_STRINGIZE = @compileError("unable to translate C expr: unexpected token '#'");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:303:9
pub inline fn _CRT_STRINGIZE(_Value: anytype) @TypeOf(__CRT_STRINGIZE(_Value)) {
    _ = &_Value;
    return __CRT_STRINGIZE(_Value);
}
pub const __CRT_WIDE = @compileError("unable to translate macro: undefined identifier `L`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:308:9
pub inline fn _CRT_WIDE(_String: anytype) @TypeOf(__CRT_WIDE(_String)) {
    _ = &_String;
    return __CRT_WIDE(_String);
}
pub const _W64 = "";
pub const _CRTIMP_NOIA64 = _CRTIMP;
pub const _CRTIMP2 = _CRTIMP;
pub const _CRTIMP_ALTERNATIVE = _CRTIMP;
pub const _CRT_ALTERNATIVE_IMPORTED = "";
pub const _MRTIMP2 = _CRTIMP;
pub const _DLL = "";
pub const _MT = "";
pub const _MCRTIMP = _CRTIMP;
pub const _CRTIMP_PURE = _CRTIMP;
pub const _PGLOBAL = "";
pub const _AGLOBAL = "";
pub const _SECURECRT_FILL_BUFFER_PATTERN = @as(c_int, 0xFD);
pub const _CRT_DEPRECATE_TEXT = @compileError("unable to translate macro: undefined identifier `deprecated`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:367:9
pub const _CRT_INSECURE_DEPRECATE_MEMORY = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:370:9
pub const _CRT_INSECURE_DEPRECATE_GLOBALS = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:374:9
pub const _CRT_MANAGED_HEAP_DEPRECATE = "";
pub const _CRT_OBSOLETE = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:382:9
pub const _CONST_RETURN = "";
pub const UNALIGNED = "";
pub const _CRT_ALIGN = @compileError("unable to translate macro: undefined identifier `__aligned__`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:409:9
pub const __CRTDECL = __cdecl;
pub const _ARGMAX = @as(c_int, 100);
pub const _TRUNCATE = @import("std").zig.c_translation.cast(usize, -@as(c_int, 1));
pub inline fn _CRT_UNUSED(x: anytype) anyopaque {
    _ = &x;
    return @import("std").zig.c_translation.cast(anyopaque, x);
}
pub const __USE_MINGW_ANSI_STDIO = @as(c_int, 0);
pub const _CRT_glob = @compileError("unable to translate macro: undefined identifier `_dowildcard`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:473:9
pub const __ANONYMOUS_DEFINED = "";
pub const _ANONYMOUS_UNION = __MINGW_EXTENSION;
pub const _ANONYMOUS_STRUCT = __MINGW_EXTENSION;
pub const _UNION_NAME = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:493:9
pub const _STRUCT_NAME = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:494:9
pub const DUMMYUNIONNAME = "";
pub const DUMMYUNIONNAME1 = "";
pub const DUMMYUNIONNAME2 = "";
pub const DUMMYUNIONNAME3 = "";
pub const DUMMYUNIONNAME4 = "";
pub const DUMMYUNIONNAME5 = "";
pub const DUMMYUNIONNAME6 = "";
pub const DUMMYUNIONNAME7 = "";
pub const DUMMYUNIONNAME8 = "";
pub const DUMMYUNIONNAME9 = "";
pub const DUMMYSTRUCTNAME = "";
pub const DUMMYSTRUCTNAME1 = "";
pub const DUMMYSTRUCTNAME2 = "";
pub const DUMMYSTRUCTNAME3 = "";
pub const DUMMYSTRUCTNAME4 = "";
pub const DUMMYSTRUCTNAME5 = "";
pub const __CRT_UUID_DECL = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:581:9
pub const __MINGW_DEBUGBREAK_IMPL = !(__has_builtin(__debugbreak) != 0);
pub const __MINGW_FASTFAIL_IMPL = !(__has_builtin(__fastfail) != 0);
pub const __MINGW_PREFETCH_IMPL = @compileError("unable to translate macro: undefined identifier `__prefetch`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/_mingw.h:638:9
pub const _CRTNOALIAS = "";
pub const _CRTRESTRICT = "";
pub const _SIZE_T_DEFINED = "";
pub const _SSIZE_T_DEFINED = "";
pub const _RSIZE_T_DEFINED = "";
pub const _INTPTR_T_DEFINED = "";
pub const __intptr_t_defined = "";
pub const _UINTPTR_T_DEFINED = "";
pub const __uintptr_t_defined = "";
pub const _PTRDIFF_T_DEFINED = "";
pub const _PTRDIFF_T_ = "";
pub const _WCHAR_T_DEFINED = "";
pub const _WCTYPE_T_DEFINED = "";
pub const _WINT_T = "";
pub const _ERRCODE_DEFINED = "";
pub const _TIME32_T_DEFINED = "";
pub const _TIME64_T_DEFINED = "";
pub const _TIME_T_DEFINED = "";
pub const _CRT_SECURE_CPP_NOTHROW = @compileError("unable to translate macro: undefined identifier `throw`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/corecrt.h:143:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0 = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/corecrt.h:262:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1 = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/corecrt.h:263:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2 = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/corecrt.h:264:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3 = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/corecrt.h:265:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4 = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/corecrt.h:266:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1 = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/corecrt.h:267:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_2 = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/corecrt.h:268:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_3 = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/corecrt.h:269:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_2_0 = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/corecrt.h:270:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/corecrt.h:271:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/corecrt.h:272:9
pub const __DEFINE_CPP_OVERLOAD_SECURE_FUNC_SPLITPATH = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/corecrt.h:273:9
pub const __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0 = @compileError("unable to translate macro: undefined identifier `__func_name`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/corecrt.h:277:9
pub const __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1 = @compileError("unable to translate macro: undefined identifier `__func_name`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/corecrt.h:279:9
pub const __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2 = @compileError("unable to translate macro: undefined identifier `__func_name`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/corecrt.h:281:9
pub const __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3 = @compileError("unable to translate macro: undefined identifier `__func_name`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/corecrt.h:283:9
pub const __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4 = @compileError("unable to translate macro: undefined identifier `__func_name`");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/corecrt.h:285:9
pub const __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/corecrt.h:422:9
pub const __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/corecrt.h:423:9
pub const __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/corecrt.h:424:9
pub const __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/corecrt.h:425:9
pub const __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/corecrt.h:426:9
pub const _TAGLC_ID_DEFINED = "";
pub const _THREADLOCALEINFO = "";
pub const __crt_typefix = @compileError("unable to translate C expr: unexpected token ''");
// C:\Users\Gabusi_F\Desktop\zig0.14\zig-x86_64-windows-0.14.1\lib\libc\include\any-windows-any/corecrt.h:486:9
pub const _CRT_USE_WINAPI_FAMILY_DESKTOP_APP = "";
pub const __need_wint_t = "";
pub const __need_wchar_t = "";
pub const _WCHAR_T = "";
pub const INT8_MIN = -@as(c_int, 128);
pub const INT16_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 32768, .decimal);
pub const INT32_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal) - @as(c_int, 1);
pub const INT64_MIN = -@as(c_longlong, 9223372036854775807) - @as(c_int, 1);
pub const INT8_MAX = @as(c_int, 127);
pub const INT16_MAX = @as(c_int, 32767);
pub const INT32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const INT64_MAX = @as(c_longlong, 9223372036854775807);
pub const UINT8_MAX = @as(c_int, 255);
pub const UINT16_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const UINT32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0xffffffff, .hex);
pub const UINT64_MAX = @as(c_ulonglong, 0xffffffffffffffff);
pub const INT_LEAST8_MIN = INT8_MIN;
pub const INT_LEAST16_MIN = INT16_MIN;
pub const INT_LEAST32_MIN = INT32_MIN;
pub const INT_LEAST64_MIN = INT64_MIN;
pub const INT_LEAST8_MAX = INT8_MAX;
pub const INT_LEAST16_MAX = INT16_MAX;
pub const INT_LEAST32_MAX = INT32_MAX;
pub const INT_LEAST64_MAX = INT64_MAX;
pub const UINT_LEAST8_MAX = UINT8_MAX;
pub const UINT_LEAST16_MAX = UINT16_MAX;
pub const UINT_LEAST32_MAX = UINT32_MAX;
pub const UINT_LEAST64_MAX = UINT64_MAX;
pub const INT_FAST8_MIN = INT8_MIN;
pub const INT_FAST16_MIN = INT16_MIN;
pub const INT_FAST32_MIN = INT32_MIN;
pub const INT_FAST64_MIN = INT64_MIN;
pub const INT_FAST8_MAX = INT8_MAX;
pub const INT_FAST16_MAX = INT16_MAX;
pub const INT_FAST32_MAX = INT32_MAX;
pub const INT_FAST64_MAX = INT64_MAX;
pub const UINT_FAST8_MAX = UINT8_MAX;
pub const UINT_FAST16_MAX = UINT16_MAX;
pub const UINT_FAST32_MAX = UINT32_MAX;
pub const UINT_FAST64_MAX = UINT64_MAX;
pub const INTPTR_MIN = INT64_MIN;
pub const INTPTR_MAX = INT64_MAX;
pub const UINTPTR_MAX = UINT64_MAX;
pub const INTMAX_MIN = INT64_MIN;
pub const INTMAX_MAX = INT64_MAX;
pub const UINTMAX_MAX = UINT64_MAX;
pub const PTRDIFF_MIN = INT64_MIN;
pub const PTRDIFF_MAX = INT64_MAX;
pub const SIG_ATOMIC_MIN = INT32_MIN;
pub const SIG_ATOMIC_MAX = INT32_MAX;
pub const SIZE_MAX = UINT64_MAX;
pub const WCHAR_MIN = @as(c_uint, 0);
pub const WCHAR_MAX = @as(c_uint, 0xffff);
pub const WINT_MIN = @as(c_uint, 0);
pub const WINT_MAX = @as(c_uint, 0xffff);
pub inline fn INT8_C(val: anytype) @TypeOf((INT_LEAST8_MAX - INT_LEAST8_MAX) + val) {
    _ = &val;
    return (INT_LEAST8_MAX - INT_LEAST8_MAX) + val;
}
pub inline fn INT16_C(val: anytype) @TypeOf((INT_LEAST16_MAX - INT_LEAST16_MAX) + val) {
    _ = &val;
    return (INT_LEAST16_MAX - INT_LEAST16_MAX) + val;
}
pub inline fn INT32_C(val: anytype) @TypeOf((INT_LEAST32_MAX - INT_LEAST32_MAX) + val) {
    _ = &val;
    return (INT_LEAST32_MAX - INT_LEAST32_MAX) + val;
}
pub const INT64_C = @import("std").zig.c_translation.Macros.LL_SUFFIX;
pub inline fn UINT8_C(val: anytype) @TypeOf(val) {
    _ = &val;
    return val;
}
pub inline fn UINT16_C(val: anytype) @TypeOf(val) {
    _ = &val;
    return val;
}
pub const UINT32_C = @import("std").zig.c_translation.Macros.U_SUFFIX;
pub const UINT64_C = @import("std").zig.c_translation.Macros.ULL_SUFFIX;
pub const INTMAX_C = @import("std").zig.c_translation.Macros.LL_SUFFIX;
pub const UINTMAX_C = @import("std").zig.c_translation.Macros.ULL_SUFFIX;
pub const __STDBOOL_H = "";
pub const __bool_true_false_are_defined = @as(c_int, 1);
pub const @"bool" = bool;
pub const @"true" = @as(c_int, 1);
pub const @"false" = @as(c_int, 0);
pub const IWRAM_DATA = @compileError("unable to translate macro: undefined identifier `section`");
// .\include/tonc_types.h:51:9
pub const EWRAM_DATA = @compileError("unable to translate macro: undefined identifier `section`");
// .\include/tonc_types.h:54:9
pub const EWRAM_BSS = @compileError("unable to translate macro: undefined identifier `section`");
// .\include/tonc_types.h:57:10
pub const IWRAM_CODE = @compileError("unable to translate macro: undefined identifier `section`");
// .\include/tonc_types.h:60:9
pub const EWRAM_CODE = @compileError("unable to translate macro: undefined identifier `section`");
// .\include/tonc_types.h:63:9
pub const ALIGN = @compileError("unable to translate macro: undefined identifier `aligned`");
// .\include/tonc_types.h:66:9
pub const ALIGN4 = @compileError("unable to translate macro: undefined identifier `aligned`");
// .\include/tonc_types.h:76:9
pub const PACKED = @compileError("unable to translate macro: undefined identifier `packed`");
// .\include/tonc_types.h:82:9
pub const DEPRECATED = @compileError("unable to translate macro: undefined identifier `deprecated`");
// .\include/tonc_types.h:88:9
pub const INLINE = @compileError("unable to translate C expr: unexpected token 'static'");
// .\include/tonc_types.h:95:9
pub const TRUE = @as(c_int, 1);
pub const FALSE = @as(c_int, 0);
pub const NULL = @import("std").zig.c_translation.cast(?*anyopaque, @as(c_int, 0));
pub const MEM_EWRAM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x02000000, .hex);
pub const MEM_IWRAM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000000, .hex);
pub const MEM_IO = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x04000000, .hex);
pub const MEM_PAL = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x05000000, .hex);
pub const MEM_VRAM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x06000000, .hex);
pub const MEM_OAM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x07000000, .hex);
pub const MEM_ROM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x08000000, .hex);
pub const MEM_SRAM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0E000000, .hex);
pub const EWRAM_SIZE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x40000, .hex);
pub const IWRAM_SIZE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x08000, .hex);
pub const PAL_SIZE = @as(c_int, 0x00400);
pub const VRAM_SIZE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x18000, .hex);
pub const OAM_SIZE = @as(c_int, 0x00400);
pub const SRAM_SIZE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10000, .hex);
pub const PAL_BG_SIZE = @as(c_int, 0x00200);
pub const PAL_OBJ_SIZE = @as(c_int, 0x00200);
pub const CBB_SIZE = @as(c_int, 0x04000);
pub const SBB_SIZE = @as(c_int, 0x00800);
pub const VRAM_BG_SIZE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10000, .hex);
pub const VRAM_OBJ_SIZE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x08000, .hex);
pub const M3_SIZE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x12C00, .hex);
pub const M4_SIZE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x09600, .hex);
pub const M5_SIZE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0A000, .hex);
pub const VRAM_PAGE_SIZE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0A000, .hex);
pub const REG_BASE = MEM_IO;
pub const MEM_PAL_BG = MEM_PAL;
pub const MEM_PAL_OBJ = MEM_PAL + PAL_BG_SIZE;
pub const MEM_VRAM_FRONT = MEM_VRAM;
pub const MEM_VRAM_BACK = MEM_VRAM + VRAM_PAGE_SIZE;
pub const MEM_VRAM_OBJ = MEM_VRAM + VRAM_BG_SIZE;
pub const pal_bg_mem = @import("std").zig.c_translation.cast([*c]COLOR, MEM_PAL);
pub const pal_obj_mem = @import("std").zig.c_translation.cast([*c]COLOR, MEM_PAL_OBJ);
pub const pal_bg_bank = @import("std").zig.c_translation.cast([*c]PALBANK, MEM_PAL);
pub const pal_obj_bank = @import("std").zig.c_translation.cast([*c]PALBANK, MEM_PAL_OBJ);
pub const tile_mem = @import("std").zig.c_translation.cast([*c]CHARBLOCK, MEM_VRAM);
pub const tile8_mem = @import("std").zig.c_translation.cast([*c]CHARBLOCK8, MEM_VRAM);
pub const tile_mem_obj = @import("std").zig.c_translation.cast([*c]CHARBLOCK, MEM_VRAM_OBJ);
pub const tile8_mem_obj = @import("std").zig.c_translation.cast([*c]CHARBLOCK8, MEM_VRAM_OBJ);
pub const se_mem = @import("std").zig.c_translation.cast([*c]SCREENBLOCK, MEM_VRAM);
pub const se_mat = @import("std").zig.c_translation.cast([*c]SCREENMAT, MEM_VRAM);
pub const vid_mem = @import("std").zig.c_translation.cast([*c]COLOR, MEM_VRAM);
pub const m3_mem = @import("std").zig.c_translation.cast([*c]M3LINE, MEM_VRAM);
pub const m4_mem = @import("std").zig.c_translation.cast([*c]M4LINE, MEM_VRAM);
pub const m5_mem = @import("std").zig.c_translation.cast([*c]M5LINE, MEM_VRAM);
pub const vid_mem_front = @import("std").zig.c_translation.cast([*c]COLOR, MEM_VRAM);
pub const vid_mem_back = @import("std").zig.c_translation.cast([*c]COLOR, MEM_VRAM_BACK);
pub const m4_mem_back = @import("std").zig.c_translation.cast([*c]M4LINE, MEM_VRAM_BACK);
pub const m5_mem_back = @import("std").zig.c_translation.cast([*c]M5LINE, MEM_VRAM_BACK);
pub const oam_mem = @import("std").zig.c_translation.cast([*c]OBJ_ATTR, MEM_OAM);
pub const obj_mem = @import("std").zig.c_translation.cast([*c]OBJ_ATTR, MEM_OAM);
pub const obj_aff_mem = @import("std").zig.c_translation.cast([*c]OBJ_AFFINE, MEM_OAM);
pub const rom_mem = @import("std").zig.c_translation.cast([*c]@"u16", MEM_ROM);
pub const sram_mem = @import("std").zig.c_translation.cast([*c]@"u8", MEM_SRAM);
pub const REG_IFBIOS = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE - @as(c_int, 0x0008)).*;
pub const REG_RESET_DST = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE - @as(c_int, 0x0006)).*;
pub const REG_ISR_MAIN = @import("std").zig.c_translation.cast([*c]fnptr, REG_BASE - @as(c_int, 0x0004)).*;
pub const REG_DISPCNT = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x0000)).*;
pub const REG_DISPSTAT = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0004)).*;
pub const REG_VCOUNT = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0006)).*;
pub const REG_BGCNT = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0008));
pub const REG_BG0CNT = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0008)).*;
pub const REG_BG1CNT = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x000A)).*;
pub const REG_BG2CNT = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x000C)).*;
pub const REG_BG3CNT = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x000E)).*;
pub const REG_BG_OFS = @import("std").zig.c_translation.cast([*c]BG_POINT, REG_BASE + @as(c_int, 0x0010));
pub const REG_BG0HOFS = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0010)).*;
pub const REG_BG0VOFS = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0012)).*;
pub const REG_BG1HOFS = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0014)).*;
pub const REG_BG1VOFS = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0016)).*;
pub const REG_BG2HOFS = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0018)).*;
pub const REG_BG2VOFS = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x001A)).*;
pub const REG_BG3HOFS = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x001C)).*;
pub const REG_BG3VOFS = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x001E)).*;
pub const REG_BG_AFFINE = @import("std").zig.c_translation.cast([*c]BG_AFFINE, REG_BASE + @as(c_int, 0x0000));
pub const REG_BG2PA = @import("std").zig.c_translation.cast([*c]vs16, REG_BASE + @as(c_int, 0x0020)).*;
pub const REG_BG2PB = @import("std").zig.c_translation.cast([*c]vs16, REG_BASE + @as(c_int, 0x0022)).*;
pub const REG_BG2PC = @import("std").zig.c_translation.cast([*c]vs16, REG_BASE + @as(c_int, 0x0024)).*;
pub const REG_BG2PD = @import("std").zig.c_translation.cast([*c]vs16, REG_BASE + @as(c_int, 0x0026)).*;
pub const REG_BG2X = @import("std").zig.c_translation.cast([*c]vs32, REG_BASE + @as(c_int, 0x0028)).*;
pub const REG_BG2Y = @import("std").zig.c_translation.cast([*c]vs32, REG_BASE + @as(c_int, 0x002C)).*;
pub const REG_BG3PA = @import("std").zig.c_translation.cast([*c]vs16, REG_BASE + @as(c_int, 0x0030)).*;
pub const REG_BG3PB = @import("std").zig.c_translation.cast([*c]vs16, REG_BASE + @as(c_int, 0x0032)).*;
pub const REG_BG3PC = @import("std").zig.c_translation.cast([*c]vs16, REG_BASE + @as(c_int, 0x0034)).*;
pub const REG_BG3PD = @import("std").zig.c_translation.cast([*c]vs16, REG_BASE + @as(c_int, 0x0036)).*;
pub const REG_BG3X = @import("std").zig.c_translation.cast([*c]vs32, REG_BASE + @as(c_int, 0x0038)).*;
pub const REG_BG3Y = @import("std").zig.c_translation.cast([*c]vs32, REG_BASE + @as(c_int, 0x003C)).*;
pub const REG_WIN0H = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0040)).*;
pub const REG_WIN1H = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0042)).*;
pub const REG_WIN0V = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0044)).*;
pub const REG_WIN1V = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0046)).*;
pub const REG_WININ = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0048)).*;
pub const REG_WINOUT = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x004A)).*;
pub const REG_WIN0R = @import("std").zig.c_translation.cast([*c]vu8, REG_BASE + @as(c_int, 0x0040)).*;
pub const REG_WIN0L = @import("std").zig.c_translation.cast([*c]vu8, REG_BASE + @as(c_int, 0x0041)).*;
pub const REG_WIN1R = @import("std").zig.c_translation.cast([*c]vu8, REG_BASE + @as(c_int, 0x0042)).*;
pub const REG_WIN1L = @import("std").zig.c_translation.cast([*c]vu8, REG_BASE + @as(c_int, 0x0043)).*;
pub const REG_WIN0B = @import("std").zig.c_translation.cast([*c]vu8, REG_BASE + @as(c_int, 0x0044)).*;
pub const REG_WIN0T = @import("std").zig.c_translation.cast([*c]vu8, REG_BASE + @as(c_int, 0x0045)).*;
pub const REG_WIN1B = @import("std").zig.c_translation.cast([*c]vu8, REG_BASE + @as(c_int, 0x0046)).*;
pub const REG_WIN1T = @import("std").zig.c_translation.cast([*c]vu8, REG_BASE + @as(c_int, 0x0047)).*;
pub const REG_WIN0CNT = @import("std").zig.c_translation.cast([*c]vu8, REG_BASE + @as(c_int, 0x0048)).*;
pub const REG_WIN1CNT = @import("std").zig.c_translation.cast([*c]vu8, REG_BASE + @as(c_int, 0x0049)).*;
pub const REG_WINOUTCNT = @import("std").zig.c_translation.cast([*c]vu8, REG_BASE + @as(c_int, 0x004A)).*;
pub const REG_WINOBJCNT = @import("std").zig.c_translation.cast([*c]vu8, REG_BASE + @as(c_int, 0x004B)).*;
pub const REG_MOSAIC = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x004C)).*;
pub const REG_BLDCNT = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0050)).*;
pub const REG_BLDALPHA = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0052)).*;
pub const REG_BLDY = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0054)).*;
pub const REG_SND1SWEEP = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0060)).*;
pub const REG_SND1CNT = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0062)).*;
pub const REG_SND1FREQ = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0064)).*;
pub const REG_SND2CNT = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0068)).*;
pub const REG_SND2FREQ = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x006C)).*;
pub const REG_SND3SEL = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0070)).*;
pub const REG_SND3CNT = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0072)).*;
pub const REG_SND3FREQ = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0074)).*;
pub const REG_SND4CNT = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0078)).*;
pub const REG_SND4FREQ = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x007C)).*;
pub const REG_SNDCNT = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x0080)).*;
pub const REG_SNDDMGCNT = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0080)).*;
pub const REG_SNDDSCNT = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0082)).*;
pub const REG_SNDSTAT = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0084)).*;
pub const REG_SNDBIAS = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0088)).*;
pub const REG_WAVE_RAM = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x0090));
pub const REG_WAVE_RAM0 = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x0090)).*;
pub const REG_WAVE_RAM1 = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x0094)).*;
pub const REG_WAVE_RAM2 = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x0098)).*;
pub const REG_WAVE_RAM3 = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x009C)).*;
pub const REG_FIFO_A = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x00A0)).*;
pub const REG_FIFO_B = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x00A4)).*;
pub const REG_DMA = @compileError("unable to translate C expr: unexpected token 'volatile'");
// .\include/tonc_memmap.h:418:9
pub const REG_DMA0SAD = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x00B0)).*;
pub const REG_DMA0DAD = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x00B4)).*;
pub const REG_DMA0CNT = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x00B8)).*;
pub const REG_DMA1SAD = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x00BC)).*;
pub const REG_DMA1DAD = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x00C0)).*;
pub const REG_DMA1CNT = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x00C4)).*;
pub const REG_DMA2SAD = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x00C8)).*;
pub const REG_DMA2DAD = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x00CC)).*;
pub const REG_DMA2CNT = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x00D0)).*;
pub const REG_DMA3SAD = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x00D4)).*;
pub const REG_DMA3DAD = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x00D8)).*;
pub const REG_DMA3CNT = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x00DC)).*;
pub const REG_TM = @compileError("unable to translate C expr: unexpected token 'volatile'");
// .\include/tonc_memmap.h:439:9
pub const REG_TM0D = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0100)).*;
pub const REG_TM0CNT = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0102)).*;
pub const REG_TM1D = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0104)).*;
pub const REG_TM1CNT = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0106)).*;
pub const REG_TM2D = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0108)).*;
pub const REG_TM2CNT = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x010A)).*;
pub const REG_TM3D = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x010C)).*;
pub const REG_TM3CNT = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x010E)).*;
pub const REG_SIOCNT = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0128)).*;
pub const REG_SIODATA = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x0120));
pub const REG_SIODATA32 = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x0120)).*;
pub const REG_SIODATA8 = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x012A)).*;
pub const REG_SIOMULTI = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0120));
pub const REG_SIOMULTI0 = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0120)).*;
pub const REG_SIOMULTI1 = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0122)).*;
pub const REG_SIOMULTI2 = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0124)).*;
pub const REG_SIOMULTI3 = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0126)).*;
pub const REG_SIOMLT_RECV = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0120)).*;
pub const REG_SIOMLT_SEND = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x012A)).*;
pub const REG_KEYINPUT = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0130)).*;
pub const REG_KEYCNT = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0132)).*;
pub const REG_RCNT = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0134)).*;
pub const REG_JOYCNT = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0140)).*;
pub const REG_JOY_RECV = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x0150)).*;
pub const REG_JOY_TRANS = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x0154)).*;
pub const REG_JOYSTAT = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0158)).*;
pub const REG_IE = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0200)).*;
pub const REG_IF = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0202)).*;
pub const REG_WAITCNT = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0204)).*;
pub const REG_IME = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0208)).*;
pub const REG_PAUSE = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0300)).*;
pub const REG_BLDMOD = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0050)).*;
pub const REG_COLEV = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0052)).*;
pub const REG_COLEY = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0054)).*;
pub const REG_SOUND1CNT = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x0060)).*;
pub const REG_SOUND1CNT_L = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0060)).*;
pub const REG_SOUND1CNT_H = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0062)).*;
pub const REG_SOUND1CNT_X = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0064)).*;
pub const REG_SOUND2CNT_L = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0068)).*;
pub const REG_SOUND2CNT_H = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x006C)).*;
pub const REG_SOUND3CNT = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x0070)).*;
pub const REG_SOUND3CNT_L = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0070)).*;
pub const REG_SOUND3CNT_H = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0072)).*;
pub const REG_SOUND3CNT_X = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0074)).*;
pub const REG_SOUND4CNT_L = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0078)).*;
pub const REG_SOUND4CNT_H = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x007C)).*;
pub const REG_SOUNDCNT = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x0080)).*;
pub const REG_SOUNDCNT_L = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0080)).*;
pub const REG_SOUNDCNT_H = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0082)).*;
pub const REG_SOUNDCNT_X = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0084)).*;
pub const REG_SOUNDBIAS = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0088)).*;
pub const REG_WAVE = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x0090));
pub const REG_FIFOA = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x00A0)).*;
pub const REG_FIFOB = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x00A4)).*;
pub const REG_DMA0CNT_L = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x00B8)).*;
pub const REG_DMA0CNT_H = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x00BA)).*;
pub const REG_DMA1CNT_L = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x00C4)).*;
pub const REG_DMA1CNT_H = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x00C6)).*;
pub const REG_DMA2CNT_L = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x00D0)).*;
pub const REG_DMA2CNT_H = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x00D2)).*;
pub const REG_DMA3CNT_L = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x00DC)).*;
pub const REG_DMA3CNT_H = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x00DE)).*;
pub const REG_TM0CNT_L = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0100)).*;
pub const REG_TM0CNT_H = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0102)).*;
pub const REG_TM1CNT_L = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0104)).*;
pub const REG_TM1CNT_H = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0106)).*;
pub const REG_TM2CNT_L = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0108)).*;
pub const REG_TM2CNT_H = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x010a)).*;
pub const REG_TM3CNT_L = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x010c)).*;
pub const REG_TM3CNT_H = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x010e)).*;
pub const REG_KEYS = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0130)).*;
pub const REG_P1 = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0130)).*;
pub const REG_P1CNT = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0132)).*;
pub const REG_SCD0 = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0120)).*;
pub const REG_SCD1 = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0122)).*;
pub const REG_SCD2 = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0124)).*;
pub const REG_SCD3 = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0126)).*;
pub const REG_SCCNT = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x0128)).*;
pub const REG_SCCNT_L = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0128)).*;
pub const REG_SCCNT_H = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x012A)).*;
pub const REG_R = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0134)).*;
pub const REG_HS_CTRL = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0140)).*;
pub const REG_JOYRE = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x0150)).*;
pub const REG_JOYRE_L = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0150)).*;
pub const REG_JOYRE_H = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0152)).*;
pub const REG_JOYTR = @import("std").zig.c_translation.cast([*c]vu32, REG_BASE + @as(c_int, 0x0154)).*;
pub const REG_JOYTR_L = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0154)).*;
pub const REG_JOYTR_H = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0156)).*;
pub const REG_JSTAT = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0158)).*;
pub const REG_WSCNT = @import("std").zig.c_translation.cast([*c]vu16, REG_BASE + @as(c_int, 0x0204)).*;
pub const TONC_VIDEO = "";
pub const TONC_MEMDEF = "";
pub const DCNT_MODE0 = @as(c_int, 0);
pub const DCNT_MODE1 = @as(c_int, 0x0001);
pub const DCNT_MODE2 = @as(c_int, 0x0002);
pub const DCNT_MODE3 = @as(c_int, 0x0003);
pub const DCNT_MODE4 = @as(c_int, 0x0004);
pub const DCNT_MODE5 = @as(c_int, 0x0005);
pub const DCNT_GB = @as(c_int, 0x0008);
pub const DCNT_PAGE = @as(c_int, 0x0010);
pub const DCNT_OAM_HBL = @as(c_int, 0x0020);
pub const DCNT_OBJ_2D = @as(c_int, 0);
pub const DCNT_OBJ_1D = @as(c_int, 0x0040);
pub const DCNT_BLANK = @as(c_int, 0x0080);
pub const DCNT_BG0 = @as(c_int, 0x0100);
pub const DCNT_BG1 = @as(c_int, 0x0200);
pub const DCNT_BG2 = @as(c_int, 0x0400);
pub const DCNT_BG3 = @as(c_int, 0x0800);
pub const DCNT_OBJ = @as(c_int, 0x1000);
pub const DCNT_WIN0 = @as(c_int, 0x2000);
pub const DCNT_WIN1 = @as(c_int, 0x4000);
pub const DCNT_WINOBJ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const DCNT_MODE_MASK = @as(c_int, 0x0007);
pub const DCNT_MODE_SHIFT = @as(c_int, 0);
pub inline fn DCNT_MODE(n: anytype) @TypeOf(n << DCNT_MODE_SHIFT) {
    _ = &n;
    return n << DCNT_MODE_SHIFT;
}
pub const DCNT_LAYER_MASK = @as(c_int, 0x1F00);
pub const DCNT_LAYER_SHIFT = @as(c_int, 8);
pub inline fn DCNT_LAYER(n: anytype) @TypeOf(n << DCNT_LAYER_SHIFT) {
    _ = &n;
    return n << DCNT_LAYER_SHIFT;
}
pub const DCNT_WIN_MASK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xE000, .hex);
pub const DCNT_WIN_SHIFT = @as(c_int, 13);
pub inline fn DCNT_WIN(n: anytype) @TypeOf(n << DCNT_WIN_SHIFT) {
    _ = &n;
    return n << DCNT_WIN_SHIFT;
}
pub inline fn DCNT_BUILD(mode: anytype, layer: anytype, win: anytype, obj1d: anytype, objhbl: anytype) @TypeOf((((((win & @as(c_int, 7)) << @as(c_int, 13)) | ((layer & @as(c_int, 31)) << @as(c_int, 8))) | ((obj1d & @as(c_int, 1)) << @as(c_int, 6))) | ((objhbl & @as(c_int, 1)) << @as(c_int, 5))) | (mode & @as(c_int, 7))) {
    _ = &mode;
    _ = &layer;
    _ = &win;
    _ = &obj1d;
    _ = &objhbl;
    return (((((win & @as(c_int, 7)) << @as(c_int, 13)) | ((layer & @as(c_int, 31)) << @as(c_int, 8))) | ((obj1d & @as(c_int, 1)) << @as(c_int, 6))) | ((objhbl & @as(c_int, 1)) << @as(c_int, 5))) | (mode & @as(c_int, 7));
}
pub const DSTAT_IN_VBL = @as(c_int, 0x0001);
pub const DSTAT_IN_HBL = @as(c_int, 0x0002);
pub const DSTAT_IN_VCT = @as(c_int, 0x0004);
pub const DSTAT_VBL_IRQ = @as(c_int, 0x0008);
pub const DSTAT_HBL_IRQ = @as(c_int, 0x0010);
pub const DSTAT_VCT_IRQ = @as(c_int, 0x0020);
pub const DSTAT_VCT_MASK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFF00, .hex);
pub const DSTAT_VCT_SHIFT = @as(c_int, 8);
pub inline fn DSTAT_VCT(n: anytype) @TypeOf(n << DSTAT_VCT_SHIFT) {
    _ = &n;
    return n << DSTAT_VCT_SHIFT;
}
pub const BG_MOSAIC = @as(c_int, 0x0040);
pub const BG_4BPP = @as(c_int, 0);
pub const BG_8BPP = @as(c_int, 0x0080);
pub const BG_WRAP = @as(c_int, 0x2000);
pub const BG_SIZE0 = @as(c_int, 0);
pub const BG_SIZE1 = @as(c_int, 0x4000);
pub const BG_SIZE2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const BG_SIZE3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xC000, .hex);
pub const BG_REG_32x32 = @as(c_int, 0);
pub const BG_REG_64x32 = @as(c_int, 0x4000);
pub const BG_REG_32x64 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const BG_REG_64x64 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xC000, .hex);
pub const BG_AFF_16x16 = @as(c_int, 0);
pub const BG_AFF_32x32 = @as(c_int, 0x4000);
pub const BG_AFF_64x64 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const BG_AFF_128x128 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xC000, .hex);
pub const BG_PRIO_MASK = @as(c_int, 0x0003);
pub const BG_PRIO_SHIFT = @as(c_int, 0);
pub inline fn BG_PRIO(n: anytype) @TypeOf(n << BG_PRIO_SHIFT) {
    _ = &n;
    return n << BG_PRIO_SHIFT;
}
pub const BG_CBB_MASK = @as(c_int, 0x000C);
pub const BG_CBB_SHIFT = @as(c_int, 2);
pub inline fn BG_CBB(n: anytype) @TypeOf(n << BG_CBB_SHIFT) {
    _ = &n;
    return n << BG_CBB_SHIFT;
}
pub const BG_SBB_MASK = @as(c_int, 0x1F00);
pub const BG_SBB_SHIFT = @as(c_int, 8);
pub inline fn BG_SBB(n: anytype) @TypeOf(n << BG_SBB_SHIFT) {
    _ = &n;
    return n << BG_SBB_SHIFT;
}
pub const BG_SIZE_MASK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xC000, .hex);
pub const BG_SIZE_SHIFT = @as(c_int, 14);
pub inline fn BG_SIZE(n: anytype) @TypeOf(n << BG_SIZE_SHIFT) {
    _ = &n;
    return n << BG_SIZE_SHIFT;
}
pub inline fn BG_BUILD(cbb: anytype, sbb: anytype, size: anytype, bpp: anytype, prio: anytype, mos: anytype, wrap_1: anytype) @TypeOf(((((((size << @as(c_int, 14)) | ((wrap_1 & @as(c_int, 1)) << @as(c_int, 13))) | ((sbb & @as(c_int, 31)) << @as(c_int, 8))) | ((bpp & @as(c_int, 8)) << @as(c_int, 4))) | ((mos & @as(c_int, 1)) << @as(c_int, 6))) | ((cbb & @as(c_int, 3)) << @as(c_int, 2))) | (prio & @as(c_int, 3))) {
    _ = &cbb;
    _ = &sbb;
    _ = &size;
    _ = &bpp;
    _ = &prio;
    _ = &mos;
    _ = &wrap_1;
    return ((((((size << @as(c_int, 14)) | ((wrap_1 & @as(c_int, 1)) << @as(c_int, 13))) | ((sbb & @as(c_int, 31)) << @as(c_int, 8))) | ((bpp & @as(c_int, 8)) << @as(c_int, 4))) | ((mos & @as(c_int, 1)) << @as(c_int, 6))) | ((cbb & @as(c_int, 3)) << @as(c_int, 2))) | (prio & @as(c_int, 3));
}
pub const WIN_BG0 = @as(c_int, 0x0001);
pub const WIN_BG1 = @as(c_int, 0x0002);
pub const WIN_BG2 = @as(c_int, 0x0004);
pub const WIN_BG3 = @as(c_int, 0x0008);
pub const WIN_OBJ = @as(c_int, 0x0010);
pub const WIN_ALL = @as(c_int, 0x001F);
pub const WIN_BLD = @as(c_int, 0x0020);
pub const WIN_LAYER_MASK = @as(c_int, 0x003F);
pub const WIN_LAYER_SHIFT = @as(c_int, 0);
pub inline fn WIN_LAYER(n: anytype) @TypeOf(n << WIN_LAYER_SHIFT) {
    _ = &n;
    return n << WIN_LAYER_SHIFT;
}
pub inline fn WIN_BUILD(low: anytype, high: anytype) @TypeOf((high << @as(c_int, 8)) | low) {
    _ = &low;
    _ = &high;
    return (high << @as(c_int, 8)) | low;
}
pub inline fn WININ_BUILD(win0: anytype, win1: anytype) @TypeOf(WIN_BUILD(win0, win1)) {
    _ = &win0;
    _ = &win1;
    return WIN_BUILD(win0, win1);
}
pub inline fn WINOUT_BUILD(out: anytype, obj: anytype) @TypeOf(WIN_BUILD(out, obj)) {
    _ = &out;
    _ = &obj;
    return WIN_BUILD(out, obj);
}
pub const MOS_BH_MASK = @as(c_int, 0x000F);
pub const MOS_BH_SHIFT = @as(c_int, 0);
pub inline fn MOS_BH(n: anytype) @TypeOf(n << MOS_BH_SHIFT) {
    _ = &n;
    return n << MOS_BH_SHIFT;
}
pub const MOS_BV_MASK = @as(c_int, 0x00F0);
pub const MOS_BV_SHIFT = @as(c_int, 4);
pub inline fn MOS_BV(n: anytype) @TypeOf(n << MOS_BV_SHIFT) {
    _ = &n;
    return n << MOS_BV_SHIFT;
}
pub const MOS_OH_MASK = @as(c_int, 0x0F00);
pub const MOS_OH_SHIFT = @as(c_int, 8);
pub inline fn MOS_OH(n: anytype) @TypeOf(n << MOS_OH_SHIFT) {
    _ = &n;
    return n << MOS_OH_SHIFT;
}
pub const MOS_OV_MASK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xF000, .hex);
pub const MOS_OV_SHIFT = @as(c_int, 12);
pub inline fn MOS_OV(n: anytype) @TypeOf(n << MOS_OV_SHIFT) {
    _ = &n;
    return n << MOS_OV_SHIFT;
}
pub inline fn MOS_BUILD(bh: anytype, bv: anytype, oh: anytype, ov: anytype) @TypeOf(((((ov & @as(c_int, 15)) << @as(c_int, 12)) | ((oh & @as(c_int, 15)) << @as(c_int, 8))) | ((bv & @as(c_int, 15)) << @as(c_int, 4))) | (bh & @as(c_int, 15))) {
    _ = &bh;
    _ = &bv;
    _ = &oh;
    _ = &ov;
    return ((((ov & @as(c_int, 15)) << @as(c_int, 12)) | ((oh & @as(c_int, 15)) << @as(c_int, 8))) | ((bv & @as(c_int, 15)) << @as(c_int, 4))) | (bh & @as(c_int, 15));
}
pub const BLD_BG0 = @as(c_int, 0x0001);
pub const BLD_BG1 = @as(c_int, 0x0002);
pub const BLD_BG2 = @as(c_int, 0x0004);
pub const BLD_BG3 = @as(c_int, 0x0008);
pub const BLD_OBJ = @as(c_int, 0x0010);
pub const BLD_ALL = @as(c_int, 0x001F);
pub const BLD_BACKDROP = @as(c_int, 0x0020);
pub const BLD_OFF = @as(c_int, 0);
pub const BLD_STD = @as(c_int, 0x0040);
pub const BLD_WHITE = @as(c_int, 0x0080);
pub const BLD_BLACK = @as(c_int, 0x00C0);
pub const BLD_TOP_MASK = @as(c_int, 0x003F);
pub const BLD_TOP_SHIFT = @as(c_int, 0);
pub inline fn BLD_TOP(n: anytype) @TypeOf(n << BLD_TOP_SHIFT) {
    _ = &n;
    return n << BLD_TOP_SHIFT;
}
pub const BLD_MODE_MASK = @as(c_int, 0x00C0);
pub const BLD_MODE_SHIFT = @as(c_int, 6);
pub inline fn BLD_MODE(n: anytype) @TypeOf(n << BLD_MODE_SHIFT) {
    _ = &n;
    return n << BLD_MODE_SHIFT;
}
pub const BLD_BOT_MASK = @as(c_int, 0x3F00);
pub const BLD_BOT_SHIFT = @as(c_int, 8);
pub inline fn BLD_BOT(n: anytype) @TypeOf(n << BLD_BOT_SHIFT) {
    _ = &n;
    return n << BLD_BOT_SHIFT;
}
pub inline fn BLD_BUILD(top: anytype, bot: anytype, mode: anytype) @TypeOf((((bot & @as(c_int, 63)) << @as(c_int, 8)) | ((mode & @as(c_int, 3)) << @as(c_int, 6))) | (top & @as(c_int, 63))) {
    _ = &top;
    _ = &bot;
    _ = &mode;
    return (((bot & @as(c_int, 63)) << @as(c_int, 8)) | ((mode & @as(c_int, 3)) << @as(c_int, 6))) | (top & @as(c_int, 63));
}
pub const BLD_EVA_MASK = @as(c_int, 0x001F);
pub const BLD_EVA_SHIFT = @as(c_int, 0);
pub inline fn BLD_EVA(n: anytype) @TypeOf(n << BLD_EVA_SHIFT) {
    _ = &n;
    return n << BLD_EVA_SHIFT;
}
pub const BLD_EVB_MASK = @as(c_int, 0x1F00);
pub const BLD_EVB_SHIFT = @as(c_int, 8);
pub inline fn BLD_EVB(n: anytype) @TypeOf(n << BLD_EVB_SHIFT) {
    _ = &n;
    return n << BLD_EVB_SHIFT;
}
pub inline fn BLDA_BUILD(eva: anytype, evb: anytype) @TypeOf((eva & @as(c_int, 31)) | ((evb & @as(c_int, 31)) << @as(c_int, 8))) {
    _ = &eva;
    _ = &evb;
    return (eva & @as(c_int, 31)) | ((evb & @as(c_int, 31)) << @as(c_int, 8));
}
pub const BLDY_MASK = @as(c_int, 0x001F);
pub const BLDY_SHIFT = @as(c_int, 0);
pub const BLDY = @compileError("unable to translate macro: undefined identifier `BLD_EY_SHIFT`");
// .\include/tonc_memdef.h:296:9
pub inline fn BLDY_BUILD(ey: anytype) @TypeOf(ey & @as(c_int, 31)) {
    _ = &ey;
    return ey & @as(c_int, 31);
}
pub const SSW_INC = @as(c_int, 0);
pub const SSW_DEC = @as(c_int, 0x0008);
pub const SSW_OFF = @as(c_int, 0x0008);
pub const SSW_SHIFT_MASK = @as(c_int, 0x0007);
pub const SSW_SHIFT_SHIFT = @as(c_int, 0);
pub inline fn SSW_SHIFT(n: anytype) @TypeOf(n << SSW_SHIFT_SHIFT) {
    _ = &n;
    return n << SSW_SHIFT_SHIFT;
}
pub const SSW_TIME_MASK = @as(c_int, 0x0070);
pub const SSW_TIME_SHIFT = @as(c_int, 4);
pub inline fn SSW_TIME(n: anytype) @TypeOf(n << SSW_TIME_SHIFT) {
    _ = &n;
    return n << SSW_TIME_SHIFT;
}
pub inline fn SSW_BUILD(shift: anytype, dir: anytype, time: anytype) @TypeOf((((time & @as(c_int, 7)) << @as(c_int, 4)) | (dir << @as(c_int, 3))) | (shift & @as(c_int, 7))) {
    _ = &shift;
    _ = &dir;
    _ = &time;
    return (((time & @as(c_int, 7)) << @as(c_int, 4)) | (dir << @as(c_int, 3))) | (shift & @as(c_int, 7));
}
pub const SSQR_DUTY1_8 = @as(c_int, 0);
pub const SSQR_DUTY1_4 = @as(c_int, 0x0040);
pub const SSQR_DUTY1_2 = @as(c_int, 0x0080);
pub const SSQR_DUTY3_4 = @as(c_int, 0x00C0);
pub const SSQR_INC = @as(c_int, 0);
pub const SSQR_DEC = @as(c_int, 0x0800);
pub const SSQR_LEN_MASK = @as(c_int, 0x003F);
pub const SSQR_LEN_SHIFT = @as(c_int, 0);
pub inline fn SSQR_LEN(n: anytype) @TypeOf(n << SSQR_LEN_SHIFT) {
    _ = &n;
    return n << SSQR_LEN_SHIFT;
}
pub const SSQR_DUTY_MASK = @as(c_int, 0x00C0);
pub const SSQR_DUTY_SHIFT = @as(c_int, 6);
pub inline fn SSQR_DUTY(n: anytype) @TypeOf(n << SSQR_DUTY_SHIFT) {
    _ = &n;
    return n << SSQR_DUTY_SHIFT;
}
pub const SSQR_TIME_MASK = @as(c_int, 0x0700);
pub const SSQR_TIME_SHIFT = @as(c_int, 8);
pub inline fn SSQR_TIME(n: anytype) @TypeOf(n << SSQR_TIME_SHIFT) {
    _ = &n;
    return n << SSQR_TIME_SHIFT;
}
pub const SSQR_IVOL_MASK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xF000, .hex);
pub const SSQR_IVOL_SHIFT = @as(c_int, 12);
pub inline fn SSQR_IVOL(n: anytype) @TypeOf(n << SSQR_IVOL_SHIFT) {
    _ = &n;
    return n << SSQR_IVOL_SHIFT;
}
pub inline fn SSQR_ENV_BUILD(ivol: anytype, dir: anytype, time: anytype) @TypeOf(((ivol << @as(c_int, 12)) | (dir << @as(c_int, 11))) | ((time & @as(c_int, 7)) << @as(c_int, 8))) {
    _ = &ivol;
    _ = &dir;
    _ = &time;
    return ((ivol << @as(c_int, 12)) | (dir << @as(c_int, 11))) | ((time & @as(c_int, 7)) << @as(c_int, 8));
}
pub const SSQR_BUILD = @compileError("unable to translate macro: undefined identifier `ivol`");
// .\include/tonc_memdef.h:368:9
pub const SFREQ_HOLD = @as(c_int, 0);
pub const SFREQ_TIMED = @as(c_int, 0x4000);
pub const SFREQ_RESET = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const SFREQ_RATE_MASK = @as(c_int, 0x07FF);
pub const SFREQ_RATE_SHIFT = @as(c_int, 0);
pub inline fn SFREQ_RATE(n: anytype) @TypeOf(n << SFREQ_RATE_SHIFT) {
    _ = &n;
    return n << SFREQ_RATE_SHIFT;
}
pub inline fn SFREQ_BUILD(rate: anytype, timed: anytype, reset: anytype) @TypeOf(((rate & @as(c_int, 0x7FF)) | (timed << @as(c_int, 14))) | (reset << @as(c_int, 15))) {
    _ = &rate;
    _ = &timed;
    _ = &reset;
    return ((rate & @as(c_int, 0x7FF)) | (timed << @as(c_int, 14))) | (reset << @as(c_int, 15));
}
pub const SDMG_LSQR1 = @as(c_int, 0x0100);
pub const SDMG_LSQR2 = @as(c_int, 0x0200);
pub const SDMG_LWAVE = @as(c_int, 0x0400);
pub const SDMG_LNOISE = @as(c_int, 0x0800);
pub const SDMG_RSQR1 = @as(c_int, 0x1000);
pub const SDMG_RSQR2 = @as(c_int, 0x2000);
pub const SDMG_RWAVE = @as(c_int, 0x4000);
pub const SDMG_RNOISE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const SDMG_LVOL_MASK = @as(c_int, 0x0007);
pub const SDMG_LVOL_SHIFT = @as(c_int, 0);
pub inline fn SDMG_LVOL(n: anytype) @TypeOf(n << SDMG_LVOL_SHIFT) {
    _ = &n;
    return n << SDMG_LVOL_SHIFT;
}
pub const SDMG_RVOL_MASK = @as(c_int, 0x0070);
pub const SDMG_RVOL_SHIFT = @as(c_int, 4);
pub inline fn SDMG_RVOL(n: anytype) @TypeOf(n << SDMG_RVOL_SHIFT) {
    _ = &n;
    return n << SDMG_RVOL_SHIFT;
}
pub const SDMG_SQR1 = @as(c_int, 0x01);
pub const SDMG_SQR2 = @as(c_int, 0x02);
pub const SDMG_WAVE = @as(c_int, 0x04);
pub const SDMG_NOISE = @as(c_int, 0x08);
pub inline fn SDMG_BUILD(_lmode: anytype, _rmode: anytype, _lvol: anytype, _rvol: anytype) @TypeOf((((_rmode << @as(c_int, 12)) | (_lmode << @as(c_int, 8))) | ((_rvol & @as(c_int, 7)) << @as(c_int, 4))) | (_lvol & @as(c_int, 7))) {
    _ = &_lmode;
    _ = &_rmode;
    _ = &_lvol;
    _ = &_rvol;
    return (((_rmode << @as(c_int, 12)) | (_lmode << @as(c_int, 8))) | ((_rvol & @as(c_int, 7)) << @as(c_int, 4))) | (_lvol & @as(c_int, 7));
}
pub inline fn SDMG_BUILD_LR(_mode: anytype, _vol: anytype) @TypeOf(SDMG_BUILD(_mode, _mode, _vol, _vol)) {
    _ = &_mode;
    _ = &_vol;
    return SDMG_BUILD(_mode, _mode, _vol, _vol);
}
pub const SDS_DMG25 = @as(c_int, 0);
pub const SDS_DMG50 = @as(c_int, 0x0001);
pub const SDS_DMG100 = @as(c_int, 0x0002);
pub const SDS_A50 = @as(c_int, 0);
pub const SDS_A100 = @as(c_int, 0x0004);
pub const SDS_B50 = @as(c_int, 0);
pub const SDS_B100 = @as(c_int, 0x0008);
pub const SDS_AR = @as(c_int, 0x0100);
pub const SDS_AL = @as(c_int, 0x0200);
pub const SDS_ATMR0 = @as(c_int, 0);
pub const SDS_ATMR1 = @as(c_int, 0x0400);
pub const SDS_ARESET = @as(c_int, 0x0800);
pub const SDS_BR = @as(c_int, 0x1000);
pub const SDS_BL = @as(c_int, 0x2000);
pub const SDS_BTMR0 = @as(c_int, 0);
pub const SDS_BTMR1 = @as(c_int, 0x4000);
pub const SDS_BRESET = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const SSTAT_SQR1 = @as(c_int, 0x0001);
pub const SSTAT_SQR2 = @as(c_int, 0x0002);
pub const SSTAT_WAVE = @as(c_int, 0x0004);
pub const SSTAT_NOISE = @as(c_int, 0x0008);
pub const SSTAT_DISABLE = @as(c_int, 0);
pub const SSTAT_ENABLE = @as(c_int, 0x0080);
pub const DMA_DST_INC = @as(c_int, 0);
pub const DMA_DST_DEC = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x00200000, .hex);
pub const DMA_DST_FIXED = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x00400000, .hex);
pub const DMA_DST_RELOAD = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x00600000, .hex);
pub const DMA_SRC_INC = @as(c_int, 0);
pub const DMA_SRC_DEC = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x00800000, .hex);
pub const DMA_SRC_FIXED = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x01000000, .hex);
pub const DMA_REPEAT = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x02000000, .hex);
pub const DMA_16 = @as(c_int, 0);
pub const DMA_32 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x04000000, .hex);
pub const DMA_AT_NOW = @as(c_int, 0);
pub const DMA_GAMEPAK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x08000000, .hex);
pub const DMA_AT_VBLANK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10000000, .hex);
pub const DMA_AT_HBLANK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x20000000, .hex);
pub const DMA_AT_SPECIAL = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x30000000, .hex);
pub const DMA_AT_FIFO = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x30000000, .hex);
pub const DMA_AT_REFRESH = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x30000000, .hex);
pub const DMA_IRQ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x40000000, .hex);
pub const DMA_ENABLE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hex);
pub const DMA_COUNT_MASK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0000FFFF, .hex);
pub const DMA_COUNT_SHIFT = @as(c_int, 0);
pub inline fn DMA_COUNT(n: anytype) @TypeOf(n << DMA_COUNT_SHIFT) {
    _ = &n;
    return n << DMA_COUNT_SHIFT;
}
pub const DMA_NOW = DMA_ENABLE | DMA_AT_NOW;
pub const DMA_16NOW = DMA_NOW | DMA_16;
pub const DMA_32NOW = DMA_NOW | DMA_32;
pub const DMA_CPY16 = DMA_NOW | DMA_16;
pub const DMA_CPY32 = DMA_NOW | DMA_32;
pub const DMA_FILL16 = (DMA_NOW | DMA_SRC_FIXED) | DMA_16;
pub const DMA_FILL32 = (DMA_NOW | DMA_SRC_FIXED) | DMA_32;
pub const DMA_HDMA = ((DMA_ENABLE | DMA_REPEAT) | DMA_AT_HBLANK) | DMA_DST_RELOAD;
pub const TM_FREQ_SYS = @as(c_int, 0);
pub const TM_FREQ_1 = @as(c_int, 0);
pub const TM_FREQ_64 = @as(c_int, 0x0001);
pub const TM_FREQ_256 = @as(c_int, 0x0002);
pub const TM_FREQ_1024 = @as(c_int, 0x0003);
pub const TM_CASCADE = @as(c_int, 0x0004);
pub const TM_IRQ = @as(c_int, 0x0040);
pub const TM_ENABLE = @as(c_int, 0x0080);
pub const TM_FREQ_MASK = @as(c_int, 0x0003);
pub const TM_FREQ_SHIFT = @as(c_int, 0);
pub inline fn TM_FREQ(n: anytype) @TypeOf(n << TM_FREQ_SHIFT) {
    _ = &n;
    return n << TM_FREQ_SHIFT;
}
pub const SIO_MODE_8BIT = @as(c_int, 0x0000);
pub const SIO_MODE_32BIT = @as(c_int, 0x1000);
pub const SIO_MODE_MULTI = @as(c_int, 0x2000);
pub const SIO_MODE_UART = @as(c_int, 0x3000);
pub const SIO_SI_HIGH = @as(c_int, 0x0004);
pub const SIO_IRQ = @as(c_int, 0x4000);
pub const SIO_MODE_MASK = @as(c_int, 0x3000);
pub const SIO_MODE_SHIFT = @as(c_int, 12);
pub inline fn SIO_MODE(n: anytype) @TypeOf(n << SIO_MODE_SHIFT) {
    _ = &n;
    return n << SIO_MODE_SHIFT;
}
pub const SION_CLK_EXT = @as(c_int, 0x0000);
pub const SION_CLK_INT = @as(c_int, 0x0001);
pub const SION_256KHZ = @as(c_int, 0x0000);
pub const SION_2MHZ = @as(c_int, 0x0002);
pub const SION_RECV_HIGH = @as(c_int, 0x0004);
pub const SION_SEND_HIGH = @as(c_int, 0x0008);
pub const SION_ENABLE = @as(c_int, 0x0080);
pub const SIOM_9600 = @as(c_int, 0x0000);
pub const SIOM_38400 = @as(c_int, 0x0001);
pub const SIOM_57600 = @as(c_int, 0x0002);
pub const SIOM_115200 = @as(c_int, 0x0003);
pub const SIOM_SI = @as(c_int, 0x0004);
pub const SIOM_SLAVE = @as(c_int, 0x0004);
pub const SIOM_SD = @as(c_int, 0x0008);
pub const SIOM_CONNECTED = @as(c_int, 0x0008);
pub const SIOM_ERROR = @as(c_int, 0x0040);
pub const SIOM_ENABLE = @as(c_int, 0x0080);
pub const SIOM_BAUD_MASK = @as(c_int, 0x0003);
pub const SIOM_BAUD_SHIFT = @as(c_int, 0);
pub inline fn SIOM_BAUD(n: anytype) @TypeOf(n << SIOM_BAUD_SHIFT) {
    _ = &n;
    return n << SIOM_BAUD_SHIFT;
}
pub const SIOM_ID_MASK = @as(c_int, 0x0030);
pub const SIOM_ID_SHIFT = @as(c_int, 4);
pub inline fn SIOM_ID(n: anytype) @TypeOf(n << SIOM_ID_SHIFT) {
    _ = &n;
    return n << SIOM_ID_SHIFT;
}
pub const SIOU_9600 = @as(c_int, 0x0000);
pub const SIOU_38400 = @as(c_int, 0x0001);
pub const SIOU_57600 = @as(c_int, 0x0002);
pub const SIOU_115200 = @as(c_int, 0x0003);
pub const SIOU_CTS = @as(c_int, 0x0004);
pub const SIOU_PARITY_EVEN = @as(c_int, 0x0000);
pub const SIOU_PARITY_ODD = @as(c_int, 0x0008);
pub const SIOU_SEND_FULL = @as(c_int, 0x0010);
pub const SIOU_RECV_EMPTY = @as(c_int, 0x0020);
pub const SIOU_ERROR = @as(c_int, 0x0040);
pub const SIOU_7BIT = @as(c_int, 0x0000);
pub const SIOU_8BIT = @as(c_int, 0x0080);
pub const SIOU_SEND = @as(c_int, 0x0100);
pub const SIOU_RECV = @as(c_int, 0x0200);
pub const SIOU_BAUD_MASK = @as(c_int, 0x0003);
pub const SIOU_BAUD_SHIFT = @as(c_int, 0);
pub inline fn SIOU_BAUD(n: anytype) @TypeOf(n << SIOU_BAUD_SHIFT) {
    _ = &n;
    return n << SIOU_BAUD_SHIFT;
}
pub const R_MODE_NORMAL = @as(c_int, 0x0000);
pub const R_MODE_MULTI = @as(c_int, 0x0000);
pub const R_MODE_UART = @as(c_int, 0x0000);
pub const R_MODE_GPIO = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const R_MODE_JOYBUS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xC000, .hex);
pub const R_MODE_MASK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xC000, .hex);
pub const R_MODE_SHIFT = @as(c_int, 14);
pub inline fn R_MODE(n: anytype) @TypeOf(n << R_MODE_SHIFT) {
    _ = &n;
    return n << R_MODE_SHIFT;
}
pub const GPIO_SC = @as(c_int, 0x0001);
pub const GPIO_SD = @as(c_int, 0x0002);
pub const GPIO_SI = @as(c_int, 0x0004);
pub const GPIO_SO = @as(c_int, 0x0008);
pub const GPIO_SC_IO = @as(c_int, 0x0010);
pub const GPIO_SD_IO = @as(c_int, 0x0020);
pub const GPIO_SI_IO = @as(c_int, 0x0040);
pub const GPIO_SO_IO = @as(c_int, 0x0080);
pub const GPIO_SC_INPUT = @as(c_int, 0x0000);
pub const GPIO_SD_INPUT = @as(c_int, 0x0000);
pub const GPIO_SI_INPUT = @as(c_int, 0x0000);
pub const GPIO_SO_INPUT = @as(c_int, 0x0000);
pub const GPIO_SC_OUTPUT = @as(c_int, 0x0010);
pub const GPIO_SD_OUTPUT = @as(c_int, 0x0020);
pub const GPIO_SI_OUTPUT = @as(c_int, 0x0040);
pub const GPIO_SO_OUTPUT = @as(c_int, 0x0080);
pub const GPIO_IRQ = @as(c_int, 0x0100);
pub const KEY_A = @as(c_int, 0x0001);
pub const KEY_B = @as(c_int, 0x0002);
pub const KEY_SELECT = @as(c_int, 0x0004);
pub const KEY_START = @as(c_int, 0x0008);
pub const KEY_RIGHT = @as(c_int, 0x0010);
pub const KEY_LEFT = @as(c_int, 0x0020);
pub const KEY_UP = @as(c_int, 0x0040);
pub const KEY_DOWN = @as(c_int, 0x0080);
pub const KEY_R = @as(c_int, 0x0100);
pub const KEY_L = @as(c_int, 0x0200);
pub const KEY_ACCEPT = @as(c_int, 0x0009);
pub const KEY_CANCEL = @as(c_int, 0x0002);
pub const KEY_RESET = @as(c_int, 0x030C);
pub const KEY_FIRE = @as(c_int, 0x0003);
pub const KEY_SPECIAL = @as(c_int, 0x000C);
pub const KEY_DIR = @as(c_int, 0x00F0);
pub const KEY_SHOULDER = @as(c_int, 0x0300);
pub const KEY_ANY = @as(c_int, 0x03FF);
pub const KEY_MASK = @as(c_int, 0x03FF);
pub const KCNT_IRQ = @as(c_int, 0x4000);
pub const KCNT_OR = @as(c_int, 0);
pub const KCNT_AND = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const IRQ_VBLANK = @as(c_int, 0x0001);
pub const IRQ_HBLANK = @as(c_int, 0x0002);
pub const IRQ_VCOUNT = @as(c_int, 0x0004);
pub const IRQ_TIMER0 = @as(c_int, 0x0008);
pub const IRQ_TIMER1 = @as(c_int, 0x0010);
pub const IRQ_TIMER2 = @as(c_int, 0x0020);
pub const IRQ_TIMER3 = @as(c_int, 0x0040);
pub const IRQ_SERIAL = @as(c_int, 0x0080);
pub const IRQ_DMA0 = @as(c_int, 0x0100);
pub const IRQ_DMA1 = @as(c_int, 0x0200);
pub const IRQ_DMA2 = @as(c_int, 0x0400);
pub const IRQ_DMA3 = @as(c_int, 0x0800);
pub const IRQ_KEYPAD = @as(c_int, 0x1000);
pub const IRQ_GAMEPAK = @as(c_int, 0x2000);
pub const WS_SRAM_4 = @as(c_int, 0);
pub const WS_SRAM_3 = @as(c_int, 0x0001);
pub const WS_SRAM_2 = @as(c_int, 0x0002);
pub const WS_SRAM_8 = @as(c_int, 0x0003);
pub const WS_ROM0_N4 = @as(c_int, 0);
pub const WS_ROM0_N3 = @as(c_int, 0x0004);
pub const WS_ROM0_N2 = @as(c_int, 0x0008);
pub const WS_ROM0_N8 = @as(c_int, 0x000C);
pub const WS_ROM0_S2 = @as(c_int, 0);
pub const WS_ROM0_S1 = @as(c_int, 0x0010);
pub const WS_ROM1_N4 = @as(c_int, 0);
pub const WS_ROM1_N3 = @as(c_int, 0x0020);
pub const WS_ROM1_N2 = @as(c_int, 0x0040);
pub const WS_ROM1_N8 = @as(c_int, 0x0060);
pub const WS_ROM1_S4 = @as(c_int, 0);
pub const WS_ROM1_S1 = @as(c_int, 0x0080);
pub const WS_ROM2_N4 = @as(c_int, 0);
pub const WS_ROM2_N3 = @as(c_int, 0x0100);
pub const WS_ROM2_N2 = @as(c_int, 0x0200);
pub const WS_ROM2_N8 = @as(c_int, 0x0300);
pub const WS_ROM2_S8 = @as(c_int, 0);
pub const WS_ROM2_S1 = @as(c_int, 0x0400);
pub const WS_PHI_OFF = @as(c_int, 0);
pub const WS_PHI_4 = @as(c_int, 0x0800);
pub const WS_PHI_2 = @as(c_int, 0x1000);
pub const WS_PHI_1 = @as(c_int, 0x1800);
pub const WS_PREFETCH = @as(c_int, 0x4000);
pub const WS_GBA = @as(c_int, 0);
pub const WS_CGB = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const WS_STANDARD = @as(c_int, 0x4317);
pub const SE_HFLIP = @as(c_int, 0x0400);
pub const SE_VFLIP = @as(c_int, 0x0800);
pub const SE_ID_MASK = @as(c_int, 0x03FF);
pub const SE_ID_SHIFT = @as(c_int, 0);
pub inline fn SE_ID(n: anytype) @TypeOf(n << SE_ID_SHIFT) {
    _ = &n;
    return n << SE_ID_SHIFT;
}
pub const SE_FLIP_MASK = @as(c_int, 0x0C00);
pub const SE_FLIP_SHIFT = @as(c_int, 10);
pub inline fn SE_FLIP(n: anytype) @TypeOf(n << SE_FLIP_SHIFT) {
    _ = &n;
    return n << SE_FLIP_SHIFT;
}
pub const SE_PALBANK_MASK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xF000, .hex);
pub const SE_PALBANK_SHIFT = @as(c_int, 12);
pub inline fn SE_PALBANK(n: anytype) @TypeOf(n << SE_PALBANK_SHIFT) {
    _ = &n;
    return n << SE_PALBANK_SHIFT;
}
pub inline fn SE_BUILD(id: anytype, PALBANK_1: anytype, hflip: anytype, vflip: anytype) @TypeOf((((id & @as(c_int, 0x03FF)) | ((hflip & @as(c_int, 1)) << @as(c_int, 10))) | ((vflip & @as(c_int, 1)) << @as(c_int, 11))) | (PALBANK_1 << @as(c_int, 12))) {
    _ = &id;
    _ = &PALBANK_1;
    _ = &hflip;
    _ = &vflip;
    return (((id & @as(c_int, 0x03FF)) | ((hflip & @as(c_int, 1)) << @as(c_int, 10))) | ((vflip & @as(c_int, 1)) << @as(c_int, 11))) | (PALBANK_1 << @as(c_int, 12));
}
pub const ATTR0_REG = @as(c_int, 0);
pub const ATTR0_AFF = @as(c_int, 0x0100);
pub const ATTR0_HIDE = @as(c_int, 0x0200);
pub const ATTR0_AFF_DBL = @as(c_int, 0x0300);
pub const ATTR0_AFF_DBL_BIT = @as(c_int, 0x0200);
pub const ATTR0_BLEND = @as(c_int, 0x0400);
pub const ATTR0_WINDOW = @as(c_int, 0x0800);
pub const ATTR0_MOSAIC = @as(c_int, 0x1000);
pub const ATTR0_4BPP = @as(c_int, 0);
pub const ATTR0_8BPP = @as(c_int, 0x2000);
pub const ATTR0_SQUARE = @as(c_int, 0);
pub const ATTR0_WIDE = @as(c_int, 0x4000);
pub const ATTR0_TALL = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const ATTR0_Y_MASK = @as(c_int, 0x00FF);
pub const ATTR0_Y_SHIFT = @as(c_int, 0);
pub inline fn ATTR0_Y(n: anytype) @TypeOf(n << ATTR0_Y_SHIFT) {
    _ = &n;
    return n << ATTR0_Y_SHIFT;
}
pub const ATTR0_MODE_MASK = @as(c_int, 0x0300);
pub const ATTR0_MODE_SHIFT = @as(c_int, 8);
pub inline fn ATTR0_MODE(n: anytype) @TypeOf(n << ATTR0_MODE_SHIFT) {
    _ = &n;
    return n << ATTR0_MODE_SHIFT;
}
pub const ATTR0_SHAPE_MASK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xC000, .hex);
pub const ATTR0_SHAPE_SHIFT = @as(c_int, 14);
pub inline fn ATTR0_SHAPE(n: anytype) @TypeOf(n << ATTR0_SHAPE_SHIFT) {
    _ = &n;
    return n << ATTR0_SHAPE_SHIFT;
}
pub inline fn ATTR0_BUILD(y: anytype, shape: anytype, bpp: anytype, mode: anytype, mos: anytype, bld: anytype, win: anytype) @TypeOf(((((((y & @as(c_int, 255)) | ((mode & @as(c_int, 3)) << @as(c_int, 8))) | ((bld & @as(c_int, 1)) << @as(c_int, 10))) | ((win & @as(c_int, 1)) << @as(c_int, 11))) | ((mos & @as(c_int, 1)) << @as(c_int, 12))) | ((bpp & @as(c_int, 8)) << @as(c_int, 10))) | ((shape & @as(c_int, 3)) << @as(c_int, 14))) {
    _ = &y;
    _ = &shape;
    _ = &bpp;
    _ = &mode;
    _ = &mos;
    _ = &bld;
    _ = &win;
    return ((((((y & @as(c_int, 255)) | ((mode & @as(c_int, 3)) << @as(c_int, 8))) | ((bld & @as(c_int, 1)) << @as(c_int, 10))) | ((win & @as(c_int, 1)) << @as(c_int, 11))) | ((mos & @as(c_int, 1)) << @as(c_int, 12))) | ((bpp & @as(c_int, 8)) << @as(c_int, 10))) | ((shape & @as(c_int, 3)) << @as(c_int, 14));
}
pub const ATTR1_HFLIP = @as(c_int, 0x1000);
pub const ATTR1_VFLIP = @as(c_int, 0x2000);
pub const ATTR1_SIZE_8 = @as(c_int, 0);
pub const ATTR1_SIZE_16 = @as(c_int, 0x4000);
pub const ATTR1_SIZE_32 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const ATTR1_SIZE_64 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xC000, .hex);
pub const ATTR1_SIZE_8x8 = @as(c_int, 0);
pub const ATTR1_SIZE_16x16 = @as(c_int, 0x4000);
pub const ATTR1_SIZE_32x32 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const ATTR1_SIZE_64x64 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xC000, .hex);
pub const ATTR1_SIZE_8x16 = @as(c_int, 0);
pub const ATTR1_SIZE_8x32 = @as(c_int, 0x4000);
pub const ATTR1_SIZE_16x32 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const ATTR1_SIZE_32x64 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xC000, .hex);
pub const ATTR1_SIZE_16x8 = @as(c_int, 0);
pub const ATTR1_SIZE_32x8 = @as(c_int, 0x4000);
pub const ATTR1_SIZE_32x16 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const ATTR1_SIZE_64x32 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xC000, .hex);
pub const ATTR1_X_MASK = @as(c_int, 0x01FF);
pub const ATTR1_X_SHIFT = @as(c_int, 0);
pub inline fn ATTR1_X(n: anytype) @TypeOf(n << ATTR1_X_SHIFT) {
    _ = &n;
    return n << ATTR1_X_SHIFT;
}
pub const ATTR1_AFF_ID_MASK = @as(c_int, 0x3E00);
pub const ATTR1_AFF_ID_SHIFT = @as(c_int, 9);
pub inline fn ATTR1_AFF_ID(n: anytype) @TypeOf(n << ATTR1_AFF_ID_SHIFT) {
    _ = &n;
    return n << ATTR1_AFF_ID_SHIFT;
}
pub const ATTR1_FLIP_MASK = @as(c_int, 0x3000);
pub const ATTR1_FLIP_SHIFT = @as(c_int, 12);
pub inline fn ATTR1_FLIP(n: anytype) @TypeOf(n << ATTR1_FLIP_SHIFT) {
    _ = &n;
    return n << ATTR1_FLIP_SHIFT;
}
pub const ATTR1_SIZE_MASK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xC000, .hex);
pub const ATTR1_SIZE_SHIFT = @as(c_int, 14);
pub inline fn ATTR1_SIZE(n: anytype) @TypeOf(n << ATTR1_SIZE_SHIFT) {
    _ = &n;
    return n << ATTR1_SIZE_SHIFT;
}
pub inline fn ATTR1_BUILDR(x: anytype, size: anytype, hflip: anytype, vflip: anytype) @TypeOf((((x & @as(c_int, 511)) | ((hflip & @as(c_int, 1)) << @as(c_int, 12))) | ((vflip & @as(c_int, 1)) << @as(c_int, 13))) | ((size & @as(c_int, 3)) << @as(c_int, 14))) {
    _ = &x;
    _ = &size;
    _ = &hflip;
    _ = &vflip;
    return (((x & @as(c_int, 511)) | ((hflip & @as(c_int, 1)) << @as(c_int, 12))) | ((vflip & @as(c_int, 1)) << @as(c_int, 13))) | ((size & @as(c_int, 3)) << @as(c_int, 14));
}
pub inline fn ATTR1_BUILDA(x: anytype, size: anytype, affid: anytype) @TypeOf(((x & @as(c_int, 511)) | ((affid & @as(c_int, 31)) << @as(c_int, 9))) | ((size & @as(c_int, 3)) << @as(c_int, 14))) {
    _ = &x;
    _ = &size;
    _ = &affid;
    return ((x & @as(c_int, 511)) | ((affid & @as(c_int, 31)) << @as(c_int, 9))) | ((size & @as(c_int, 3)) << @as(c_int, 14));
}
pub const ATTR2_ID_MASK = @as(c_int, 0x03FF);
pub const ATTR2_ID_SHIFT = @as(c_int, 0);
pub inline fn ATTR2_ID(n: anytype) @TypeOf(n << ATTR2_ID_SHIFT) {
    _ = &n;
    return n << ATTR2_ID_SHIFT;
}
pub const ATTR2_PRIO_MASK = @as(c_int, 0x0C00);
pub const ATTR2_PRIO_SHIFT = @as(c_int, 10);
pub inline fn ATTR2_PRIO(n: anytype) @TypeOf(n << ATTR2_PRIO_SHIFT) {
    _ = &n;
    return n << ATTR2_PRIO_SHIFT;
}
pub const ATTR2_PALBANK_MASK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xF000, .hex);
pub const ATTR2_PALBANK_SHIFT = @as(c_int, 12);
pub inline fn ATTR2_PALBANK(n: anytype) @TypeOf(n << ATTR2_PALBANK_SHIFT) {
    _ = &n;
    return n << ATTR2_PALBANK_SHIFT;
}
pub inline fn ATTR2_BUILD(id: anytype, pb: anytype, prio: anytype) @TypeOf(((id & @as(c_int, 0x3FF)) | ((pb & @as(c_int, 15)) << @as(c_int, 12))) | ((prio & @as(c_int, 3)) << @as(c_int, 10))) {
    _ = &id;
    _ = &pb;
    _ = &prio;
    return ((id & @as(c_int, 0x3FF)) | ((pb & @as(c_int, 15)) << @as(c_int, 12))) | ((prio & @as(c_int, 3)) << @as(c_int, 10));
}
pub const TONC_CORE = "";
pub inline fn BIT(n: anytype) @TypeOf(@as(c_int, 1) << n) {
    _ = &n;
    return @as(c_int, 1) << n;
}
pub inline fn BIT_SHIFT(a: anytype, n: anytype) @TypeOf(a << n) {
    _ = &a;
    _ = &n;
    return a << n;
}
pub inline fn BIT_MASK(len: anytype) @TypeOf(BIT(len) - @as(c_int, 1)) {
    _ = &len;
    return BIT(len) - @as(c_int, 1);
}
pub const BIT_SET = @compileError("unable to translate C expr: expected ')' instead got '|='");
// .\include/tonc_core.h:44:9
pub const BIT_CLEAR = @compileError("unable to translate C expr: expected ')' instead got '&='");
// .\include/tonc_core.h:47:9
pub const BIT_FLIP = @compileError("unable to translate C expr: expected ')' instead got '^='");
// .\include/tonc_core.h:50:9
pub inline fn BIT_EQ(y: anytype, flag: anytype) @TypeOf((y & flag) == flag) {
    _ = &y;
    _ = &flag;
    return (y & flag) == flag;
}
pub inline fn BF_MASK(shift: anytype, len: anytype) @TypeOf(BIT_MASK(len) << shift) {
    _ = &shift;
    _ = &len;
    return BIT_MASK(len) << shift;
}
pub inline fn _BF_GET(y: anytype, shift: anytype, len: anytype) @TypeOf((y >> shift) & BIT_MASK(len)) {
    _ = &y;
    _ = &shift;
    _ = &len;
    return (y >> shift) & BIT_MASK(len);
}
pub inline fn _BF_PREP(x: anytype, shift: anytype, len: anytype) @TypeOf((x & BIT_MASK(len)) << shift) {
    _ = &x;
    _ = &shift;
    _ = &len;
    return (x & BIT_MASK(len)) << shift;
}
pub const _BF_SET = @compileError("unable to translate C expr: expected ')' instead got '='");
// .\include/tonc_core.h:68:9
pub const BFN_PREP = @compileError("unable to translate macro: undefined identifier `_SHIFT`");
// .\include/tonc_core.h:84:9
pub const BFN_GET = @compileError("unable to translate macro: undefined identifier `_MASK`");
// .\include/tonc_core.h:87:9
pub const BFN_SET = @compileError("unable to translate macro: undefined identifier `_MASK`");
// .\include/tonc_core.h:90:9
pub const BFN_CMP = @compileError("unable to translate macro: undefined identifier `_MASK`");
// .\include/tonc_core.h:93:9
pub const BFN_PREP2 = @compileError("unable to translate macro: undefined identifier `_MASK`");
// .\include/tonc_core.h:97:9
pub const BFN_GET2 = @compileError("unable to translate macro: undefined identifier `_MASK`");
// .\include/tonc_core.h:100:9
pub const BFN_SET2 = @compileError("unable to translate macro: undefined identifier `_MASK`");
// .\include/tonc_core.h:103:9
pub const countof = @compileError("unable to translate C expr: expected ')' instead got '['");
// .\include/tonc_core.h:129:9
pub const GRIT_CPY = @compileError("unable to translate macro: undefined identifier `Len`");
// .\include/tonc_core.h:138:9
pub const DMA_TRANSFER = @compileError("unable to translate C expr: unexpected token 'do'");
// .\include/tonc_core.h:244:9
pub inline fn SND_RATE(note: anytype, oct: anytype) @TypeOf(@as(c_int, 2048) - (__snd_rates[@as(usize, @intCast(note))] >> (@as(c_int, 4) + oct))) {
    _ = &note;
    _ = &oct;
    return @as(c_int, 2048) - (__snd_rates[@as(usize, @intCast(note))] >> (@as(c_int, 4) + oct));
}
pub const STR = @compileError("unable to translate C expr: unexpected token '#'");
// .\include/tonc_core.h:303:9
pub inline fn XSTR(x: anytype) @TypeOf(STR(x)) {
    _ = &x;
    return STR(x);
}
pub const ASM_CMT = @compileError("unable to translate C expr: unexpected token 'asm'");
// .\include/tonc_core.h:313:9
pub const ASM_BREAK = @compileError("unable to translate C expr: unexpected token 'asm'");
// .\include/tonc_core.h:316:9
pub const ASM_NOP = @compileError("unable to translate C expr: unexpected token 'asm'");
// .\include/tonc_core.h:319:9
pub const QRAN_SHIFT = @as(c_int, 15);
pub const QRAN_MASK = (@as(c_int, 1) << QRAN_SHIFT) - @as(c_int, 1);
pub const QRAN_MAX = QRAN_MASK;
pub const SCREEN_WIDTH = @as(c_int, 240);
pub const SCREEN_HEIGHT = @as(c_int, 160);
pub const M3_WIDTH = SCREEN_WIDTH;
pub const M3_HEIGHT = SCREEN_HEIGHT;
pub const M4_WIDTH = SCREEN_WIDTH;
pub const M4_HEIGHT = SCREEN_HEIGHT;
pub const M5_WIDTH = @as(c_int, 160);
pub const M5_HEIGHT = @as(c_int, 128);
pub const SCREEN_WIDTH_T = @import("std").zig.c_translation.MacroArithmetic.div(SCREEN_WIDTH, @as(c_int, 8));
pub const SCREEN_HEIGHT_T = @import("std").zig.c_translation.MacroArithmetic.div(SCREEN_HEIGHT, @as(c_int, 8));
pub const SCREEN_LINES = @as(c_int, 228);
pub const SCR_W = SCREEN_WIDTH;
pub const SCR_H = SCREEN_HEIGHT;
pub const SCR_WT = SCREEN_WIDTH_T;
pub const SCR_HT = SCREEN_HEIGHT_T;
pub const LAYER_BG0 = @as(c_int, 0x0001);
pub const LAYER_BG1 = @as(c_int, 0x0002);
pub const LAYER_BG2 = @as(c_int, 0x0004);
pub const LAYER_BG3 = @as(c_int, 0x0008);
pub const LAYER_OBJ = @as(c_int, 0x0010);
pub const LAYER_BD = @as(c_int, 0x0020);
pub const CLR_BLACK = @as(c_int, 0x0000);
pub const CLR_RED = @as(c_int, 0x001F);
pub const CLR_LIME = @as(c_int, 0x03E0);
pub const CLR_YELLOW = @as(c_int, 0x03FF);
pub const CLR_BLUE = @as(c_int, 0x7C00);
pub const CLR_MAG = @as(c_int, 0x7C1F);
pub const CLR_CYAN = @as(c_int, 0x7FE0);
pub const CLR_WHITE = @as(c_int, 0x7FFF);
pub const CLR_DEAD = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xDEAD, .hex);
pub const CLR_MAROON = @as(c_int, 0x0010);
pub const CLR_GREEN = @as(c_int, 0x0200);
pub const CLR_OLIVE = @as(c_int, 0x0210);
pub const CLR_ORANGE = @as(c_int, 0x021F);
pub const CLR_NAVY = @as(c_int, 0x4000);
pub const CLR_PURPLE = @as(c_int, 0x4010);
pub const CLR_TEAL = @as(c_int, 0x4200);
pub const CLR_GRAY = @as(c_int, 0x4210);
pub const CLR_MEDGRAY = @as(c_int, 0x5294);
pub const CLR_SILVER = @as(c_int, 0x6318);
pub const CLR_MONEYGREEN = @as(c_int, 0x6378);
pub const CLR_FUCHSIA = @as(c_int, 0x7C1F);
pub const CLR_SKYBLUE = @as(c_int, 0x7B34);
pub const CLR_CREAM = @as(c_int, 0x7BFF);
pub const CLR_MASK = @as(c_int, 0x001F);
pub const RED_MASK = @as(c_int, 0x001F);
pub const RED_SHIFT = @as(c_int, 0);
pub const GREEN_MASK = @as(c_int, 0x03E0);
pub const GREEN_SHIFT = @as(c_int, 5);
pub const BLUE_MASK = @as(c_int, 0x7C00);
pub const BLUE_SHIFT = @as(c_int, 10);
pub inline fn CBB_CLEAR(cbb: anytype) @TypeOf(memset32(&tile_mem[@as(usize, @intCast(cbb))], @as(c_int, 0), @import("std").zig.c_translation.MacroArithmetic.div(CBB_SIZE, @as(c_int, 4)))) {
    _ = &cbb;
    return memset32(&tile_mem[@as(usize, @intCast(cbb))], @as(c_int, 0), @import("std").zig.c_translation.MacroArithmetic.div(CBB_SIZE, @as(c_int, 4)));
}
pub inline fn SBB_CLEAR(sbb: anytype) @TypeOf(memset32(&se_mem[@as(usize, @intCast(sbb))], @as(c_int, 0), @import("std").zig.c_translation.MacroArithmetic.div(SBB_SIZE, @as(c_int, 4)))) {
    _ = &sbb;
    return memset32(&se_mem[@as(usize, @intCast(sbb))], @as(c_int, 0), @import("std").zig.c_translation.MacroArithmetic.div(SBB_SIZE, @as(c_int, 4)));
}
pub inline fn SBB_CLEAR_ROW(sbb: anytype, row: anytype) @TypeOf(memset32(&se_mem[@as(usize, @intCast(sbb))][@as(usize, @intCast(row * @as(c_int, 32)))], @as(c_int, 0), @import("std").zig.c_translation.MacroArithmetic.div(@as(c_int, 32), @as(c_int, 2)))) {
    _ = &sbb;
    _ = &row;
    return memset32(&se_mem[@as(usize, @intCast(sbb))][@as(usize, @intCast(row * @as(c_int, 32)))], @as(c_int, 0), @import("std").zig.c_translation.MacroArithmetic.div(@as(c_int, 32), @as(c_int, 2)));
}
pub const __BG_TYPES = (@as(c_int, 0x0C7F) << @as(c_int, 16)) | @as(c_int, 0x0C40);
pub inline fn BG_IS_AFFINE(n: anytype) @TypeOf((__BG_TYPES >> ((@as(c_int, 4) * (REG_DISPCNT & @as(c_int, 7))) + n)) & @as(c_int, 1)) {
    _ = &n;
    return (__BG_TYPES >> ((@as(c_int, 4) * (REG_DISPCNT & @as(c_int, 7))) + n)) & @as(c_int, 1);
}
pub inline fn BG_IS_AVAIL(n: anytype) @TypeOf((__BG_TYPES >> (((@as(c_int, 4) * (REG_DISPCNT & @as(c_int, 7))) + n) + @as(c_int, 16))) & @as(c_int, 1)) {
    _ = &n;
    return (__BG_TYPES >> (((@as(c_int, 4) * (REG_DISPCNT & @as(c_int, 7))) + n) + @as(c_int, 16))) & @as(c_int, 1);
}
pub inline fn M3_CLEAR() @TypeOf(memset32(vid_mem, @as(c_int, 0), @import("std").zig.c_translation.MacroArithmetic.div(M3_SIZE, @as(c_int, 4)))) {
    return memset32(vid_mem, @as(c_int, 0), @import("std").zig.c_translation.MacroArithmetic.div(M3_SIZE, @as(c_int, 4)));
}
pub inline fn M4_CLEAR() @TypeOf(memset32(vid_page, @as(c_int, 0), @import("std").zig.c_translation.MacroArithmetic.div(M4_SIZE, @as(c_int, 4)))) {
    return memset32(vid_page, @as(c_int, 0), @import("std").zig.c_translation.MacroArithmetic.div(M4_SIZE, @as(c_int, 4)));
}
pub inline fn M5_CLEAR() @TypeOf(memset32(vid_page, @as(c_int, 0), @import("std").zig.c_translation.MacroArithmetic.div(M5_SIZE, @as(c_int, 4)))) {
    return memset32(vid_page, @as(c_int, 0), @import("std").zig.c_translation.MacroArithmetic.div(M5_SIZE, @as(c_int, 4)));
}
pub const TONC_BIOS = "";
pub const ROM_RESTART = @as(c_int, 0x00);
pub const RAM_RESTART = @as(c_int, 0x01);
pub const RESET_EWRAM = @as(c_int, 0x0001);
pub const RESET_IWRAM = @as(c_int, 0x0002);
pub const RESET_PALETTE = @as(c_int, 0x0004);
pub const RESET_VRAM = @as(c_int, 0x0008);
pub const RESET_OAM = @as(c_int, 0x0010);
pub const RESET_REG_SIO = @as(c_int, 0x0020);
pub const RESET_REG_SOUND = @as(c_int, 0x0040);
pub const RESET_REG = @as(c_int, 0x0080);
pub const RESET_MEM_MASK = @as(c_int, 0x001F);
pub const RESET_REG_MASK = @as(c_int, 0x00E0);
pub const RESET_GFX = @as(c_int, 0x001C);
pub const CS_CPY = @as(c_int, 0);
pub const CS_FILL = @as(c_int, 1) << @as(c_int, 24);
pub const CS_CPY16 = @as(c_int, 0);
pub const CS_CPY32 = @as(c_int, 1) << @as(c_int, 26);
pub const CS_FILL32 = @as(c_int, 5) << @as(c_int, 24);
pub const CFS_CPY = CS_CPY;
pub const CFS_FILL = CS_FILL;
pub const BG_AFF_OFS = @as(c_int, 2);
pub const OBJ_AFF_OFS = @as(c_int, 8);
pub const BUP_ALL_OFS = @as(c_int, 1) << @as(c_int, 31);
pub const LZ_TYPE = @as(c_int, 0x00000010);
pub const LZ_SIZE_MASK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFFFFFF00, .hex);
pub const LZ_SIZE_SHIFT = @as(c_int, 8);
pub const HUF_BPP_MASK = @as(c_int, 0x0000000F);
pub const HUF_TYPE = @as(c_int, 0x00000020);
pub const HUF_SIZE_MASK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFFFFFF00, .hex);
pub const HUF_SIZE_SHIFT = @as(c_int, 8);
pub const RL_TYPE = @as(c_int, 0x00000030);
pub const RL_SIZE_MASK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFFFFFF00, .hex);
pub const RL_SIZE_SHIFT = @as(c_int, 8);
pub const DIF_8 = @as(c_int, 0x00000001);
pub const DIF_16 = @as(c_int, 0x00000002);
pub const DIF_TYPE = @as(c_int, 0x00000080);
pub const DIF_SIZE_MASK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFFFFFF00, .hex);
pub const DIF_SIZE_SHIFT = @as(c_int, 8);
pub const MBOOT_NORMAL = @as(c_int, 0x00);
pub const MBOOT_MULTI = @as(c_int, 0x01);
pub const MBOOT_FAST = @as(c_int, 0x02);
pub const swi_call = @compileError("unable to translate C expr: unexpected token '__asm'");
// .\include/tonc_bios.h:153:9
pub const DivMod = Mod;
pub const TONC_MATH = "";
pub inline fn ABS(x: anytype) @TypeOf(if (x >= @as(c_int, 0)) x else -x) {
    _ = &x;
    return if (x >= @as(c_int, 0)) x else -x;
}
pub inline fn SGN(x: anytype) @TypeOf(if (x >= @as(c_int, 0)) @as(c_int, 1) else -@as(c_int, 1)) {
    _ = &x;
    return if (x >= @as(c_int, 0)) @as(c_int, 1) else -@as(c_int, 1);
}
pub const SGN2 = SGN;
pub inline fn SGN3(x: anytype) @TypeOf(if (x > @as(c_int, 0)) @as(c_int, 1) else if (x < @as(c_int, 0)) -@as(c_int, 1) else @as(c_int, 0)) {
    _ = &x;
    return if (x > @as(c_int, 0)) @as(c_int, 1) else if (x < @as(c_int, 0)) -@as(c_int, 1) else @as(c_int, 0);
}
pub inline fn MAX(a: anytype, b: anytype) @TypeOf(if (a > b) a else b) {
    _ = &a;
    _ = &b;
    return if (a > b) a else b;
}
pub inline fn MIN(a: anytype, b: anytype) @TypeOf(if (a < b) a else b) {
    _ = &a;
    _ = &b;
    return if (a < b) a else b;
}
pub const SWAP2 = @compileError("unable to translate C expr: unexpected token 'do'");
// .\include/tonc_math.h:85:9
pub const SWAP = SWAP2;
pub const SWAP3 = @compileError("unable to translate C expr: unexpected token 'do'");
// .\include/tonc_math.h:93:9
pub inline fn IN_RANGE(x: anytype, min_1: anytype, max_2: anytype) @TypeOf((x >= min_1) and (x < max_2)) {
    _ = &x;
    _ = &min_1;
    _ = &max_2;
    return (x >= min_1) and (x < max_2);
}
pub inline fn CLAMP(x: anytype, min_1: anytype, max_2: anytype) @TypeOf(if (x >= max_2) max_2 - @as(c_int, 1) else if (x < min_1) min_1 else x) {
    _ = &x;
    _ = &min_1;
    _ = &max_2;
    return if (x >= max_2) max_2 - @as(c_int, 1) else if (x < min_1) min_1 else x;
}
pub inline fn REFLECT(x: anytype, min_1: anytype, max_2: anytype) @TypeOf(if (x >= max_2) (@as(c_int, 2) * (max_2 - @as(c_int, 1))) - x else if (x < min_1) (@as(c_int, 2) * min_1) - x else x) {
    _ = &x;
    _ = &min_1;
    _ = &max_2;
    return if (x >= max_2) (@as(c_int, 2) * (max_2 - @as(c_int, 1))) - x else if (x < min_1) (@as(c_int, 2) * min_1) - x else x;
}
pub inline fn WRAP(x: anytype, min_1: anytype, max_2: anytype) @TypeOf(if (x >= max_2) (x + min_1) - max_2 else if (x < min_1) (x + max_2) - min_1 else x) {
    _ = &x;
    _ = &min_1;
    _ = &max_2;
    return if (x >= max_2) (x + min_1) - max_2 else if (x < min_1) (x + max_2) - min_1 else x;
}
pub const FIX_SHIFT = @as(c_int, 8);
pub const FIX_SCALE = @as(c_int, 1) << FIX_SHIFT;
pub const FIX_MASK = FIX_SCALE - @as(c_int, 1);
pub const FIX_SCALEF = @import("std").zig.c_translation.cast(f32, FIX_SCALE);
pub const FIX_SCALEF_INV = @import("std").zig.c_translation.MacroArithmetic.div(@as(f64, 1.0), FIX_SCALEF);
pub const FIX_ONE = FIX_SCALE;
pub inline fn FX_RECIPROCAL(a: anytype, fp: anytype) @TypeOf(@import("std").zig.c_translation.MacroArithmetic.div(((@as(c_int, 1) << fp) + a) - @as(c_int, 1), a)) {
    _ = &a;
    _ = &fp;
    return @import("std").zig.c_translation.MacroArithmetic.div(((@as(c_int, 1) << fp) + a) - @as(c_int, 1), a);
}
pub inline fn FX_RECIMUL(x: anytype, a: anytype, fp: anytype) @TypeOf(@import("std").zig.c_translation.MacroArithmetic.div(x * (((@as(c_int, 1) << fp) + a) - @as(c_int, 1)), a) >> fp) {
    _ = &x;
    _ = &a;
    _ = &fp;
    return @import("std").zig.c_translation.MacroArithmetic.div(x * (((@as(c_int, 1) << fp) + a) - @as(c_int, 1)), a) >> fp;
}
pub const SIN_LUT_SIZE = @as(c_int, 514);
pub const DIV_LUT_SIZE = @as(c_int, 257);
pub const threadlocaleinfostruct = struct_threadlocaleinfostruct;
pub const threadmbcinfostruct = struct_threadmbcinfostruct;
pub const __lc_time_data = struct___lc_time_data;
pub const localeinfo_struct = struct_localeinfo_struct;
pub const tagLC_ID = struct_tagLC_ID;
